<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java/Kotlin Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">
        <link rel="stylesheet" href="././mdbook-admonish.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="./theme/catppuccin-admonish.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="java-distributions.html">Java distributions</a></li><li class="chapter-item expanded "><a href="java-setup.html">Java setup</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Kotlin</li><li class="chapter-item expanded "><a href="std-library/kotlin-std-library/kotlin-std-library.html">Standard library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std-library/kotlin-std-library/types.html">Types</a></li><li class="chapter-item expanded "><a href="std-library/kotlin-std-library/collections.html">Collections</a></li><li class="chapter-item expanded "><a href="std-library/kotlin-std-library/mutability.html">Mutability</a></li><li class="chapter-item expanded "><a href="std-library/kotlin-std-library/scope-functions.html">Scope functions</a></li><li class="chapter-item expanded "><a href="std-library/kotlin-std-library/use.html">use</a></li><li class="chapter-item expanded "><div>Preconditions</div></li><li class="chapter-item expanded "><div>Result</div></li></ol></li><li class="chapter-item expanded "><a href="modifiers.html">Modifiers</a></li><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/class.html">Class structure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/methods.html">Methods</a></li><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/companion-object.html">Companion object</a></li><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/property.html">Property</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/property-with-getter.html">With getter</a></li><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/property-with-setter.html">With setter</a></li><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/property-with-getter-and-setter.html">With getter and setter</a></li><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/lazy-property.html">Lazy property</a></li><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/late-init-property.html">Late-init property</a></li></ol></li><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/constructor.html">Constructor</a></li><li class="chapter-item expanded "><a href="classes-and-objects/class-structure/initializer-block.html">Initializer block</a></li></ol></li><li class="chapter-item expanded "><a href="classes-and-objects/classes-and-objects.html">Classes and objects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="classes-and-objects/interface.html">Interface</a></li><li class="chapter-item expanded "><a href="classes-and-objects/data-class.html">Data class</a></li><li class="chapter-item expanded "><a href="classes-and-objects/object.html">Object</a></li><li class="chapter-item expanded "><a href="classes-and-objects/data-object.html">Data object</a></li><li class="chapter-item expanded "><a href="classes-and-objects/enum-class.html">Enum class</a></li><li class="chapter-item expanded "><a href="classes-and-objects/sealed-class.html">Sealed class</a></li><li class="chapter-item expanded "><a href="classes-and-objects/inline-class.html">Inline class</a></li><li class="chapter-item expanded "><a href="classes-and-objects/compile-time-constants.html">Compile-time constants</a></li></ol></li><li class="chapter-item expanded "><a href="exception-handling.html">Exception handling</a></li><li class="chapter-item expanded "><a href="extensions.html">Extensions</a></li><li class="chapter-item expanded "><a href="generics/generics.html">Generics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/basics.html">Basics</a></li><li class="chapter-item expanded "><a href="generics/upper-bounds.html">With upper bounds</a></li><li class="chapter-item expanded "><a href="generics/type-erasure.html">With erased type</a></li><li class="chapter-item expanded "><div>Variance</div></li></ol></li><li class="chapter-item expanded "><a href="reflection/kotlin.html">Reflection</a></li><li class="chapter-item expanded "><a href="control-flow/control-flow.html">Control flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control-flow/local-and-non-local-return.html">Local and non-local return</a></li></ol></li><li class="chapter-item expanded "><div>Annotation</div></li><li class="chapter-item expanded "><div>Concurrency</div></li><li class="chapter-item expanded "><a href="java-interoperability.html">Java interoperability</a></li><li class="chapter-item expanded "><a href="gotchas.html">Gotchas</a></li><li class="chapter-item expanded "><a href="common-design-patterns.html">Common design patterns</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Java</li><li class="chapter-item expanded "><a href="std-library/java-std-library/index.html">Standard library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std-library/java-std-library/types.html">Types</a></li></ol></li><li class="chapter-item expanded "><div>Record</div></li><li class="chapter-item expanded "><a href="reflection/java.html">Reflection</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">JSRs</li><li class="chapter-item expanded "><a href="jsr/what-is-jsr.html">What is JSR?</a></li><li class="chapter-item expanded "><div>Database</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="jsr/jpa.html">ORM: JPA</a></li><li class="chapter-item expanded "><a href="jsr/jdbc.html">Database access: JDBC</a></li></ol></li><li class="chapter-item expanded "><a href="jsr/dependency-injection.html">Dependency injection</a></li><li class="chapter-item expanded "><a href="jsr/validation.html">Validation</a></li><li class="chapter-item expanded "><a href="jsr/others.html">Others</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Toolchain</li><li class="chapter-item expanded "><a href="compiler-plugin.html">Compiler plugin</a></li><li class="chapter-item expanded "><a href="compile-and-build/compile-and-build.html">Compile and build</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compile-and-build/compile.html">Compile</a></li><li class="chapter-item expanded "><a href="compile-and-build/decompile.html">Decompile</a></li><li class="chapter-item expanded "><a href="compile-and-build/compiler-options.html">Compiler options</a></li><li class="chapter-item expanded "><div>Gradle</div></li><li class="chapter-item expanded "><a href="local-repository.html">Local repository</a></li></ol></li><li class="chapter-item expanded "><a href="optimisations.html">Optimisations</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">JVM</li><li class="chapter-item expanded "><a href="jvm/memory.html">Memory</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java/Kotlin Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>This Kotlin book is written mainly for the JVM target.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-distributions"><a class="header" href="#java-distributions">Java distributions</a></h1>
<p><a href="https://en.wikipedia.org/wiki/OpenJDK">OpenJDK</a> is the reference implementation of Java SE.</p>
<p>Here are the different Java distributions for the OpenJDK implementation:</p>
<div class="table-wrapper"><table><thead><tr><th>Distribution</th><th>From</th><th>LTS</th></tr></thead><tbody>
<tr><td>Eclipse Temurin</td><td>Adoptium</td><td>Yes</td></tr>
<tr><td>Amazon Corretto</td><td>Amazon</td><td>Yes</td></tr>
<tr><td>Azul Zulu</td><td>Azul Systems</td><td>Yes</td></tr>
<tr><td>Oracle OpenJDK</td><td>Oracle</td><td>No!</td></tr>
<tr><td>Oracle Java SSE</td><td>Oracle</td><td>Yes</td></tr>
<tr><td>Red Hat build of OpenJDK</td><td>Red Hat</td><td>Yes</td></tr>
<tr><td>GraalVM Community Edition</td><td>GraalVM</td><td>Yes</td></tr>
</tbody></table>
</div>
<p>TCK (Technology Compatibility Kit) is a suite of tests that checks for JSR compliance. Java distribution builds are usually TCK-tested.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-setup"><a class="header" href="#java-setup">Java setup</a></h1>
<h2 id="where-are-all-the-javas"><a class="header" href="#where-are-all-the-javas">Where are all the javas?</a></h2>
<pre><code>mdfind -name 'java' | grep '/bin/java$'
</code></pre>
<p>The following doesn‚Äôt show Brew-installed Java:</p>
<pre><code>/usr/libexec/java_home -V
</code></pre>
<p>Common locations</p>
<ul>
<li><code>/usr/local/Cellar</code></li>
<li><code>/Library/Java/JavaVirtualMachines</code></li>
<li><code>~/Library/Java/JavaVirtualMachines</code></li>
<li><code>/Applications/IntelliJ IDEA.app/Contents/jbr/Contents/Home</code></li>
</ul>
<h2 id="jdk-and-jre"><a class="header" href="#jdk-and-jre">JDK and JRE</a></h2>
<p>.jdk files only have JDK, you need JRE</p>
<h2 id="how-does-java_home-work-who-uses-it"><a class="header" href="#how-does-java_home-work-who-uses-it">How does JAVA_HOME work, who uses it</a></h2>
<p><code>JAVA_HOME</code> is used by ./gradlew</p>
<p>If no <code>JAVA_HOME</code> is set, the highest JDK available from running <code>/usr/libexec/java_home</code> will be used (to be verified).</p>
<h2 id="how-to-install-ca-certs"><a class="header" href="#how-to-install-ca-certs">How to install CA certs?</a></h2>
<p>Use <code>keytool</code>.</p>
<p>For Gradle wrappers, use</p>
<pre><code>./gradlew¬†build --refresh-dependencies -Djavax.net.ssl.trustStore=&lt;path-to-the-cacert-file&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin-std-library"><a class="header" href="#kotlin-std-library">Kotlin std library</a></h1>
<p>Kotlin standard libraries are <code>kotlin-stdlib</code>, <code>kotlin-reflect</code> and <code>kotlin-script-*</code>.</p>
<p>As of Kotlin 1.8.0, these libraries are compiled with JVM target 1.8. As a result, the <code>kotlin-stdlib-jdk7</code> and <code>kotlin-stdlib-jdk8</code> are no longer needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h2>
<p>Note that Kotlin compiles non-nullable primitive types to their corresponding primitive types in Java.</p>
<p><strong>Nullable primitive types, on the other hand, are compiled to the corresponding boxed types in Java.</strong></p>
<h2 id="any"><a class="header" href="#any"><code>Any</code></a></h2>
<div id="admonition-gotcha" class="admonition admonish-warning">
<div class="admonition-title">
<p>Gotcha</p>
<p><a class="admonition-anchor-link" href="std-library/kotlin-std-library/types.html#admonition-gotcha"></a></p>
</div>
<div>
<p><code>Any</code> type <em>can</em> be <code>null</code> üò±.</p>
<pre><code class="language-kotlin">val foo: Any = null as Any
</code></pre>
</div>
</div>
<h2 id="any-1"><a class="header" href="#any-1"><code>Any?</code></a></h2>
<p><code>Any?</code> type can be <code>null</code>.</p>
<pre><code class="language-kotlin">val foo: Any? = null
</code></pre>
<h2 id="list"><a class="header" href="#list"><code>List&lt;*&gt;</code></a></h2>
<p>Wildcard types <code>*</code> are basically <code>Any?</code> (?).</p>
<pre><code class="language-kotlin">val foo: List&lt;*&gt; = listOf(null, 1)
foo.forEach { println(it) }
</code></pre>
<pre><code class="language-kotlin">val foo: List&lt;Any?&gt; = listOf(null, 1)
foo.forEach { println(it) }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p><code>asSequence</code>  generator, lazy evaluate, <code>generateSequence</code>, <code>sequenceOf</code>, <code>sequence</code>, <code>yield</code>, <code>yieldAll</code>. use terminal operations like <code>toList()</code> or <code>sum()</code> to evaluate.</p>
<blockquote>
<p>‚ö†Ô∏è Sequence performs all the processing steps <strong>one-by-one</strong>!</p>
</blockquote>
<blockquote>
<p>‚ö†Ô∏è Some overhead!</p>
</blockquote>
<ul>
<li>
<p>Array</p>
<p>Egs: Array, IntArray, CharArray, DoubleArray</p>
<ul>
<li>Data in arrays are stored in a sequential manner</li>
<li>Size is determined</li>
<li>fixed size elements</li>
<li>Cannot reassign (invariant)</li>
</ul>
</li>
<li>
<p>List</p>
<p>Read-only</p>
<ul>
<li><code>List</code>
Default implementation: ArrayList</li>
<li><code>ArrayList</code>
Resizable array</li>
</ul>
<p>M<strong>utable</strong></p>
<ul>
<li><code>MutableList</code></li>
</ul>
</li>
<li>
<p>Set</p>
<p>Read-only</p>
<ul>
<li><code>Set</code>
Default implementation: LinkedHashSet</li>
<li><code>HashSet</code>
Less memory, order not preserved</li>
<li><code>LinkedHashSet</code>
preserves order of elements insertion</li>
</ul>
<p>M<strong>utable</strong></p>
<ul>
<li><code>MutableSet</code></li>
</ul>
</li>
<li>
<p>Map</p>
<p>Read-only</p>
<ul>
<li><code>Map</code>
Default implementation: LinkedHashMap</li>
<li><code>HashMap</code>
Less memory, order not preserved</li>
<li><code>LinkedHashMap</code>
preserves order of elements insertion</li>
</ul>
<p>M<strong>utable</strong></p>
<ul>
<li><code>MutableMap</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutability"><a class="header" href="#mutability">Mutability</a></h1>
<h2 id="immutable"><a class="header" href="#immutable">Immutable</a></h2>
<p>State cannot be modified after it is created. </p>
<ul>
<li><code>String</code></li>
</ul>
<div id="admonition-warning" class="admonition admonish-warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="std-library/kotlin-std-library/mutability.html#admonition-warning"></a></p>
</div>
<div>
<p><code>List</code> is not actually immutable. Rather, it is compile-time read-only.</p>
<p>You can cast a <code>List</code> into a <code>MutableList</code> and change the underlying data at runtime üò±.</p>
<p>Example how we can change the data in a <code>List</code>:</p>
<pre><code class="language-kotlin">val list = listOf(1,2,3)

println(list)

(list as MutableList&lt;Int&gt;)[2] = 999

println(list)
</code></pre>
<p>For more immutable support, use Google's Guava or JetBrain's Kotlinx Immutable Collections Library.</p>
</div>
</div>
<h2 id="mutable"><a class="header" href="#mutable">Mutable</a></h2>
<p>Read-only: val, List. Compile-time</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="std-library/kotlin-std-library/mutability.html#admonition-note"></a></p>
</div>
<div>
<p><code>val</code> means cannot reassign</p>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="std-library/kotlin-std-library/mutability.html#admonition-note-1"></a></p>
</div>
<div>
<p><code>ReadOnlyDataStructure</code> means cannot write</p>
</div>
</div>
<p>Grammar</p>
<ol>
<li><code>val</code> + <code>ReadOnlyDataStructure</code>
<ul>
<li>Cannot write</li>
<li>Cannot reassign</li>
</ul>
</li>
<li><code>var</code> + <code>ReadOnlyDataStructure</code>
<ul>
<li>Cannot write</li>
<li>Can reassign</li>
</ul>
</li>
<li><code>val</code> + <code>MutableDataStructure</code>
<ul>
<li>Can write</li>
<li>Cannot reassign</li>
</ul>
</li>
<li><code>var</code> + <code>MutableDataStructure</code>
<ul>
<li>Can write</li>
<li>Can reassign</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-functions"><a class="header" href="#scope-functions">Scope functions</a></h1>
<p>There are 5 scoped functions - <code>let</code>, <code>apply</code>, <code>run</code>, <code>also</code> and <code>with</code>.</p>
<p>The only scoped functions that I use are <code>let</code> and <code>apply</code>.</p>
<h2 id="let"><a class="header" href="#let"><strong>let</strong></a></h2>
<p>For me I use the <code>let</code> idiom mainly when dealing with <code>null</code>s.</p>
<pre><code class="language-kotlin">fun printName(name: String) {
	println(name)
}

fun main() {
	val name: String? = &quot;Harry&quot;
	name?.let { printName(it) }
}
</code></pre>
<p>or use a function reference:</p>
<pre><code class="language-kotlin">fun printName(name: String) {
	println(name)
}

fun main() {
	val name: String? = &quot;Harry&quot;
	name?.let(::printName)
}
</code></pre>
<h2 id="apply"><a class="header" href="#apply"><strong>apply</strong></a></h2>
<p>I use <code>apply</code> a lot, especially with old Java libraries.</p>
<p>Instead of:</p>
<pre><code class="language-kotlin noplayground">val person = Person(&quot;Adam&quot;)
person.age = 32
person.city = &quot;London&quot;   
person.address = &quot;bla&quot;  
</code></pre>
<p>do:</p>
<pre><code class="language-kotlin noplayground">val person = Person(&quot;Adam&quot;).apply {
	age = 32
	city = &quot;London&quot;   
	address = &quot;bla&quot;       
}
</code></pre>
<h2 id="run"><a class="header" href="#run"><strong>run</strong></a></h2>
<ul>
<li>When you need to <em>initialise and compute</em> <em>to derive at one goal</em></li>
<li>When you don't need an object but only use it to compute something</li>
</ul>
<pre><code class="language-kotlin">class Person {
	var age = 0
	fun futureAge(years: Int) = age + years
}
val person = Person()
</code></pre>
<pre><code class="language-kotlin">person.age = 50
person.doThis()
person.thenThat()
val ageInTenDecades = futureAge(100)
</code></pre>
<pre><code class="language-kotlin">val ageInTenDecades = person.run {
	age = 50
	doThis()
	thenThat()
	getFinalFutureAge(100)
}
</code></pre>
<h2 id="with"><a class="header" href="#with"><strong>with</strong></a></h2>
<ul>
<li>When you already have an object but you need to keep <em>calling</em> its members (maybe useful in tests when you need to assert several things).</li>
</ul>
<p>Similar to <code>run</code></p>
<pre><code class="language-kotlin">data class Persona(val name: String, val age: Int, val address: String, val occupation: String)

val person = Persona(&quot;Alice&quot;, 100, &quot;Sesame Street&quot;, &quot;Coder&quot;)
</code></pre>
<pre><code class="language-kotlin">require(person.name == &quot;Alice&quot;)
require(person.age == 100)
require(person.address == &quot;Sesame Street&quot;)
require(person.occupation == &quot;Coder&quot;)
</code></pre>
<pre><code class="language-kotlin">with(person) {
	require(name == &quot;Alice&quot;)
	require(age == 100)
	require(address == &quot;Sesame Street&quot;)
	require(occupation == &quot;Coder&quot;)
}
</code></pre>
<pre><code class="language-kotlin">with(person) {
	applyForBusinessName()
	registerAddress()
	applyForLicence()
}
</code></pre>
<h2 id="also-duplicate"><a class="header" href="#also-duplicate"><strong><del>also (duplicate?)</del></strong></a></h2>
<p>When you want to create an object and add some side effects to it. Similar to <code>apply</code>.</p>
<p>before</p>
<pre><code class="language-kotlin">val alice = Person(&quot;Alice&quot;, 20)
println(alice)
alice.moveTo(&quot;London&quot;)
</code></pre>
<p>after</p>
<pre><code class="language-kotlin">val alice = Person(&quot;Alice&quot;, 20)
println(alice)
alice.moveTo(&quot;London&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use"><a class="header" href="#use">use</a></h1>
<p>The <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/use.html"><code>use</code></a> block cleans up closeable resources whether an exception is thrown or not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modifiers"><a class="header" href="#modifiers">Modifiers</a></h1>
<p>Access/visibility modifiers: <code>public</code>, <code>private</code>, <code>protected</code>, <code>internal</code>
Inheritance modifiers: <code>final</code>, <code>open</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-structure"><a class="header" href="#class-structure">Class structure</a></h1>
<p>Classes are <code>final</code> by default, i.e. cannot be subclassed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<ul>
<li><a href="classes-and-objects/class-structure/methods.html#equals"><code>equals</code></a></li>
<li><a href="classes-and-objects/class-structure/methods.html#hashcode"><code>hashCode</code></a></li>
<li><a href="classes-and-objects/class-structure/methods.html#tostring"><code>toString</code></a></li>
<li>Operator overloading - includes <code>invoke</code> and <code>compareTo</code>. See <a href="https://kotlinlang.org/docs/operator-overloading.html">docs</a>.</li>
</ul>
<hr />
<h2 id="equals"><a class="header" href="#equals"><code>equals</code></a></h2>
<p>Suppose you have</p>
<pre><code class="language-kotlin">class StringWrapper(private val str: String)

fun main() {
    val wrapper1 = StringWrapper(&quot;jonas&quot;)
    val wrapper2 = StringWrapper(&quot;jonas&quot;)
    println(wrapper1 == wrapper2)  // you want this to be true
}
</code></pre>
<p>To make <code>wrapper1 == wrapper2</code> return <code>true</code>, we can override the <code>equals</code> operator:</p>
<pre><code class="language-kotlin">class StringWrapper(private val str: String) {
    override fun equals(other: Any?): Boolean {
        return when (other) {
            is StringWrapper -&gt; str == other.str
            is String -&gt; str == other
            else -&gt; false
        }
    }
}

fun main() {
    val wrapper1 = StringWrapper(&quot;jonas&quot;)
    val wrapper2 = StringWrapper(&quot;jonas&quot;)

    println(wrapper1 == wrapper2)
    println(wrapper1.equals(wrapper2))
    // println(wrapper1 == &quot;jonas&quot;)  // this won't work
    println(wrapper1.equals(&quot;jonas&quot;))
}
</code></pre>
<p>‚ö†Ô∏è But that's not enough. You need to make sure that you fulfil the <code>hashCode</code> <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/hash-code.html">contract</a>.</p>
<h2 id="hashcode"><a class="header" href="#hashcode"><code>hashCode</code></a></h2>
<p>Afaik, you would normally implement <code>hashCode</code> and <code>equals</code> together.</p>
<p>This is the implementation of <code>StringWrapper</code> that overrides both <code>hashCode</code> and <code>equals</code> functions.</p>
<pre><code class="language-kotlin">class StringWrapper(private val str: String) {

    override fun hashCode(): Int {
        return str.hashCode()
    }

    override fun equals(other: Any?): Boolean {
        return when (other) {
            is StringWrapper -&gt; str.hashCode() == other.hashCode()
            is String -&gt; str.hashCode() == other.hashCode()
            else -&gt; false
        }
    }
}

fun main() {
    val wrapper1 = StringWrapper(&quot;jonas&quot;)
    val wrapper2 = StringWrapper(&quot;jonas&quot;)

    println(wrapper1 == wrapper2)
    println(wrapper1.hashCode() == wrapper2.hashCode())
    println(&quot;jonas&quot;.hashCode() == wrapper1.hashCode())
    println(&quot;jonas&quot;.hashCode() == wrapper2.hashCode())
}
</code></pre>
<h2 id="tostring"><a class="header" href="#tostring"><code>toString</code></a></h2>
<p>The default string representation is the class name, followed by <code>@</code>, and the object's hash code (in hexadecimal):</p>
<pre><code class="language-kotlin">class SecureString(str: String)

fun main() {
    val password = SecureString(&quot;pA55w0rd&quot;)
    println(&quot;Password is: $password&quot;)
    println(&quot;%x&quot;.format(password.hashCode()))
}
</code></pre>
<p>We can override <code>toString</code>:</p>
<pre><code class="language-kotlin">class SecureString(str: String) {
    override fun toString(): String {
        return &quot;***** (redacted)&quot;
    }
}

fun main() {
    val password = SecureString(&quot;pA55w0rd&quot;)
    println(&quot;Password is: $password&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="companion-object"><a class="header" href="#companion-object">Companion object</a></h1>
<p>An object declaration inside a class is called a <code>companion object</code>. These are singleton objects that are tied to a class, not the instance.</p>
<p>Companion objects are usually used for:</p>
<ol>
<li>Declaring constants (see <strong>Compile-time constants</strong>)</li>
<li>Declaring factory methods</li>
</ol>
<p>Here is an example of using a <code>companion object</code> to declare both a constant and a factory method:</p>
<pre><code class="language-kotlin">class Person(val age: Int) {
    companion object {
        const val AGE_AT_ENROLMENT = 18

        fun createStudent(): Person {
            return Person(age = AGE_AT_ENROLMENT)
        }
    }
}

fun main() {
    val person = Person.createStudent()
    println(person.age)
}
</code></pre>
<p>You can access the properties in a companion object from a class:</p>
<pre><code class="language-kotlin">class Person {
    companion object {
        val hobbies = listOf(&quot;swimming&quot;, &quot;jogging&quot;)
    }
}

fun main() {
    println(Person.hobbies)
}
</code></pre>
<p>You can even access the <code>object</code> itself:</p>
<pre><code class="language-kotlin">class Person {
    companion object {
        val hobbies = listOf(&quot;swimming&quot;, &quot;jogging&quot;)
    }
}

fun main() {
    println(Person.Companion)
    println(Person.Companion.hobbies)
}
</code></pre>
<p>You cannot, however, access these objects from an instance (you need reflection for that):</p>
<pre><code class="language-kotlin">class Person {
    companion object {
        val hobbies = listOf(&quot;swimming&quot;, &quot;jogging&quot;)
    }
}

fun main() {
    val person = Person()
    println(person.hobbies)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property"><a class="header" href="#property">Property</a></h1>
<p>Class properties are computed once in the lifetime of a class.</p>
<pre><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area: Int = this.height * this.width
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}
</code></pre>
<p>(JVM only, I think) The getter and setter methods will be generated accordingly for the <code>val</code> and <code>var</code> properties. Attempting to redefine any of these methods throws a compilation error:</p>
<pre><code class="language-kotlin">class Rectangle(val height: Int, val width: Int) {
	fun getHeight(): Int {
		return 9
	}
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.getHeight())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-with-getter"><a class="header" href="#property-with-getter">Property with getter</a></h1>
<p>If we want <code>area</code> to be computed on the fly,</p>
<pre><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area: Int
		get() {
			return this.width * this.height
		}
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}
</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="classes-and-objects/class-structure/property-with-getter.html#admonition-note"></a></p>
</div>
<div>
<p>Another pattern to compute <code>area</code> on the fly is to have a <code>getArea</code> method:</p>
<pre><code>class Rectangle(var height: Int, var width: Int) {
	fun getArea() = this.height * this.width
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.getArea())
	rectangle.height = 100
	println(rectangle.getArea())
}
</code></pre>
<p>For me... I prefer the getter properties pattern.</p>
</div>
</div>
<p>We can also use the single-line function expression:</p>
<pre><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area: Int
		get() = this.width * this.height
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}
</code></pre>
<p>Whether we use the single-line function expression or the function block syntax, we can omit the type if it can be inferred:</p>
<pre><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area
		get() = this.width * this.height
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}
</code></pre>
<p>We can also reduce this getter property to one line:</p>
<pre><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area get() = this.width * this.height
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}
</code></pre>
<p>A getter is always read, not written to. So, this property cannot be a <code>var</code> (otherwise it would be an oxymoron) - it won't compile:</p>
<pre><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	var area: Int
		get() = this.width * this.height
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}
</code></pre>
<p>We can set the read-only property to be private too:</p>
<pre><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	private val area: Int
		get() = this.width * this.height
}
</code></pre>
<p>The <code>private</code> in <code>private get()</code> is redundant:</p>
<pre><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	private val area: Int
		private get() = this.width * this.height
}
</code></pre>
<p>The visibility of <code>area</code> must match its <code>get</code> method. Otherwise, it won't compile:</p>
<pre><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area: Int
		private get() = this.width * this.height
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-with-setter"><a class="header" href="#property-with-setter">Property with setter</a></h1>
<p>This is how you add a setter:</p>
<pre><code class="language-kotlin">class Person {
    var age: Int = 30
        set(value) {
            field = value - 1  // alter the age every time we set it
        }
}

fun main() {
	val person = Person()
	person.age = 20
	println(person.age)
}
</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="classes-and-objects/class-structure/property-with-setter.html#admonition-note"></a></p>
</div>
<div>
<p><code>set(value)</code> is actually <code>set(value: Int)</code>. The type of <code>value</code> is the same as the type of the property, hence you don't need to type it. The name <code>value</code> is a convention, but you can rename it just like you would any other function.</p>
</div>
</div>
<div id="admonition-note-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="classes-and-objects/class-structure/property-with-setter.html#admonition-note-1"></a></p>
</div>
<div>
<p><code>field</code> (&quot;backing field&quot;) is like the &quot;internal value&quot; of the property, if you may.</p>
</div>
</div>
<p>You cannot make <code>age</code> read-only because you are writing value to it (&quot;setter&quot;). So this will fail:</p>
<pre><code class="language-kotlin">class Person {
    val age: Int = 30
        set(value) {
            field = value - 1  // alter the age every time we set it
        }
}

fun main() {
	val person = Person()
	person.age = 20
	println(person.age)
}
</code></pre>
<p>You also need to provide an initial value because it assigns the backing field <code>field</code> directly. This won't compile because none is set:</p>
<pre><code class="language-kotlin">class Person {
    var age: Int
        set(value) {
            field = value - 1  // alter the age every time we set it
        }
}

fun main() {
	val person = Person()
	person.age = 20
	println(person.age)
}
</code></pre>
<div id="admonition-unintended-recursion" class="admonition admonish-bug">
<div class="admonition-title">
<p>Unintended recursion</p>
<p><a class="admonition-anchor-link" href="classes-and-objects/class-structure/property-with-setter.html#admonition-unintended-recursion"></a></p>
</div>
<div>
<p>Be careful of recursion which will lead to stack overflow ‚Äî the compiler doesn't warn. The following example set <code>age</code> to 20, which calls <code>alterAge</code>, which in turn sets <code>this.age</code>, which calls <code>alterAge</code>,  which in turn sets <code>this.age</code>, ...</p>
<pre><code class="language-kotlin">class Person {
    var age: Int = 30
        set(value) {
            alterAge(value)
        }

    private fun alterAge(newAge: Int) {
        this.age = newAge - 1
    }
}

fun main() {
	val person = Person()
	person.age = 20
	println(person.age)
}
</code></pre>
</div>
</div>
<p>Like a getter, you can set the setter to be private:</p>
<pre><code class="language-kotlin">class Person {
    private var age: Int = 30
        set(value) {
            field = value - 1  // alter the age every time we set it
        }
    fun setAge(age:)
}

fun main() {
	val person = Person()
	println(person.age)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-getter-and-setter"><a class="header" href="#with-getter-and-setter">With getter and setter</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-property"><a class="header" href="#lazy-property">Lazy property</a></h1>
<p>You can initialise a property lazily, i.e. the value will be computed only when you call it.</p>
<pre><code class="language-kotlin">class Person(val height: Float, val weight: Float) {
    val bmi: Float by lazy {
        println(&quot;Computing BMI...&quot;)
        this.weight / (this.height*this.height)
    }
}

fun main() {
    val person = Person(1.70f, 60f)
    println(person.bmi)
}
</code></pre>
<p>A lazy property is, by definition, a read-only property. It wouldn't work if you declare it as <code>var</code>:</p>
<pre><code class="language-kotlin">class Person(val height: Float, val weight: Float) {
    var bmi: Float by lazy {
        println(&quot;Computing BMI...&quot;)
        this.weight / (this.height*this.height)
    }
}

fun main() {
    val person = Person(1.70f, 60f)
    println(person.bmi)
}
</code></pre>
<p>Be careful, though! The lazy property is computed <em>once</em> in the object's lifetime.</p>
<p>(The compiler shouldn't even have allowed this... It should have checked for you whether the <code>this.weight</code> and <code>this.height</code> are mutable.)</p>
<pre><code class="language-kotlin">class Person(var height: Float, var weight: Float) {
    val bmi: Float by lazy {
        println(&quot;Computing BMI...&quot;)
        this.weight / (this.height*this.height)
    }
}

fun main() {
    val person = Person(1.70f, 60f)
    println(person.bmi)
    person.weight += 20
    println(person.bmi)
}
</code></pre>
<p>The example above should have been a getter property instead since we expect <code>bmi</code> to change.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="classes-and-objects/class-structure/lazy-property.html#admonition-note"></a></p>
</div>
<div>
<p>Lazy properties are thread-safe: one thread computes, but all threads will see the same value.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="late-init-property"><a class="header" href="#late-init-property">Late-init property</a></h1>
<p>You can initialise (non-null) properties after an object has been created.</p>
<p>A late-init property... the only time I see it used is in Spring Boot.</p>
<p>Because it will be initialised after the creation of an object, the property must be <code>var</code>.</p>
<p>Note that lateinit variables cannot be declared with primitive types or null type in Kotlin. See Baeldung's post <a href="https://www.baeldung.com/kotlin/lateinit-primitive-types">here</a>.</p>
<p><a href="https://stackoverflow.com/questions/36623177/kotlin-property-initialization-using-by-lazy-vs-lateinit">https://stackoverflow.com/questions/36623177/kotlin-property-initialization-using-by-lazy-vs-lateinit</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructor"><a class="header" href="#constructor">Constructor</a></h1>
<p>Perhaps the only idiomatic way is to have one primary constructor without the <code>constructor</code> keyword (first example). </p>
<p>If there are multiple constructors, use either (i) a primary constructor with default parameters or (ii) the factory pattern.</p>
<h3 id="one-primary-constructor"><a class="header" href="#one-primary-constructor">One primary constructor</a></h3>
<pre><code class="language-kotlin">class Person(name: String, age: Int)

fun main() {
	val person = Person(&quot;Jonah&quot;, 10)
	println(person)
}
</code></pre>
<h3 id="one-primary-constructor-with-computed-property"><a class="header" href="#one-primary-constructor-with-computed-property">One primary constructor with computed property???</a></h3>
<pre><code class="language-kotlin">class Rectangle(
	height: Int, 
	width: Int, 
	val area: Int = height * width,
)

fun main() {
	val rectangle = Rectangle(2, 10)
	println(rectangle.area)
}
</code></pre>
<h3 id="one-primary-constructor-with-constructor-keyword"><a class="header" href="#one-primary-constructor-with-constructor-keyword">One primary constructor (with <code>constructor</code> keyword)</a></h3>
<pre><code class="language-kotlin">class Person constructor(name: String, age: Int)

fun main() {
	val person = Person(&quot;Jonah&quot;, 10)
	println(person)
}
</code></pre>
<h3 id="one-primary-and-one-secondary-constructor"><a class="header" href="#one-primary-and-one-secondary-constructor">One primary and one secondary constructor</a></h3>
<pre><code class="language-kotlin">class Person(name: String, age: Int) {
	constructor(name: String): this(name, 20)
}

fun main() {
	val person = Person(&quot;Jonah&quot;)
	println(person)
}
</code></pre>
<h3 id="one-primary-and-one-secondary-constructor-with-block"><a class="header" href="#one-primary-and-one-secondary-constructor-with-block">One primary and one secondary constructor with block</a></h3>
<pre><code class="language-kotlin">class Person(name: String, age: Int) {
	constructor(name: String): this(name, 20) {
		println(&quot;Constructing...&quot;)
	}
}

fun main() {
	val person = Person(&quot;Jonah&quot;)
	println(person)
}
</code></pre>
<h3 id="one-secondary-constructor-only"><a class="header" href="#one-secondary-constructor-only">One secondary constructor only</a></h3>
<pre><code class="language-kotlin">class Person {
	constructor(name: String) {
		println(&quot;Constructing $name&quot;)
	}
}

fun main() {
	val person = Person(&quot;Jonah&quot;)
	println(person)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initializer-block"><a class="header" href="#initializer-block">Initializer block</a></h1>
<p>Are init blocks idiomatic, though?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-and-objects"><a class="header" href="#classes-and-objects">Classes and objects</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interface"><a class="header" href="#interface">Interface</a></h1>
<p>Note that in Kotlin, interfaces can declare functions <em>and/or properties</em>. Here is an example with a property:</p>
<pre><code class="language-kotlin">interface Hello {
    val name: String
}

class Greeter : Hello {
    override val name: String
        get() = &quot;Jonas&quot;
}

fun main() {
    val greeter = Greeter()
    println(greeter.name)
}
</code></pre>
<p>Interfaces cannot have private abstract properties or functions unless they are concrete implementations.</p>
<pre><code class="language-kotlin">interface Hello {
    private fun greet()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-class"><a class="header" href="#data-class">Data class</a></h1>
<p>Data class is like a <code>class</code> but implements for you:</p>
<ul>
<li><code>equals()</code> and <code>hashCode()</code></li>
<li><code>toString()</code></li>
<li><code>copy()</code></li>
</ul>
<p>Data class is the idiomatic way to define objects that contains only data. A common operation you would perform on data is comparison - this is where the <code>equals</code> function comes in handy.</p>
<p>Note that data classes, however, do not translate to Java's Records. You need the <code>@JvmRecord</code> annotation.</p>
<div id="admonition-copy" class="admonition admonish-note">
<div class="admonition-title">
<p>Copy</p>
<p><a class="admonition-anchor-link" href="classes-and-objects/data-class.html#admonition-copy"></a></p>
</div>
<div>
<p><code>.copy()</code> performs a <em>shallow</em> copy.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-declaration"><a class="header" href="#object-declaration">Object declaration</a></h1>
<p>Used for singleton or one-time class overrides.</p>
<p>Simple object declaration</p>
<pre><code class="language-kotlin">val someObject = object {
    val num = 5
}
println(someObject.num)
</code></pre>
<p>Object declaration with a method</p>
<pre><code class="language-kotlin">val someObject = object {
    fun greet() {
        println(&quot;Hello!&quot;)
    }
}
someObject.greet()
</code></pre>
<p>Object that inherits from an interface</p>
<pre><code class="language-kotlin">interface Minimisable {
    fun minimise(): Int
}

fun main() {
    val item = object : Minimisable {
        override fun minimise(): Int {
            return 1
        }
    }
    println(item.minimise())
}
</code></pre>
<p>Object declarations work with multiple interfaces too.</p>
<pre><code class="language-kotlin">interface Minimisable {
    fun minimise(): Int
}

interface Maximisable {
    fun maximise(): Int
}

fun main() {
    val item = object : Minimisable, Maximisable {
        override fun minimise(): Int {
            return 1
        }
        override fun maximise(): Int {
            return 100
        }
    }
    println(item.minimise())
    println(item.maximise())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-object"><a class="header" href="#data-object">Data object</a></h1>
<p>(Experimental)</p>
<p>Data objects would play nicely with sealed classes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-class"><a class="header" href="#enum-class">Enum class</a></h1>
<p>Useful Kotlin built-in extensions:</p>
<ul>
<li><a href="classes-and-objects/enum-class.html#enum-class">Enum class</a>
<ul>
<li><a href="classes-and-objects/enum-class.html#enumvalueof"><code>enumValueOf</code></a></li>
<li><a href="classes-and-objects/enum-class.html#enumvalues"><code>enumValues</code></a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="enumvalueof"><a class="header" href="#enumvalueof"><code>enumValueOf</code></a></h2>
<pre><code class="language-kotlin">enum class Status {
    Approved,
    Rejected,
}

fun main() {
    val status = enumValueOf&lt;Status&gt;(&quot;Approved&quot;)
    println(status)
}
</code></pre>
<div id="admonition-gotcha" class="admonition admonish-warning">
<div class="admonition-title">
<p>Gotcha</p>
<p><a class="admonition-anchor-link" href="classes-and-objects/enum-class.html#admonition-gotcha"></a></p>
</div>
<div>
<p>You have to remember to catch the exception yourself if the parse fails (yucks) (instead of the API returning a nullable). Below will throw an <code>IllegalArgumentException</code>:</p>
<pre><code class="language-kotlin">enum class Status {
    Approved,
    Rejected,
}

fun main() {
    val status = enumValueOf&lt;Status&gt;(&quot;Approvedssss&quot;)
    println(status)
}
</code></pre>
</div>
</div>
<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/enum-value-of.html">Reference</a></p>
<h2 id="enumvalues"><a class="header" href="#enumvalues"><code>enumValues</code></a></h2>
<pre><code class="language-kotlin">enum class Status {
    Approved,
    Rejected,
}

fun main() {
    val statuses = enumValues&lt;Status&gt;().toList()
    println(statuses)
}
</code></pre>
<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/enum-values.html">Reference</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sealed-class"><a class="header" href="#sealed-class">Sealed class</a></h1>
<p>Sealed classes are a powerful feature in Kotlin. They are akin to the types in Rust and Haskell ecosystem.</p>
<p>A sealed class is idiomatically used as an enum with arbitrary data structures.</p>
<pre><code class="language-kotlin">sealed class Employee {
	data class Manager(val name: String, val age: Int): Employee()
	data class SeniorDev(val name: String): Employee()
}

fun main() {
	val employee: Employee = Employee.SeniorDev(&quot;Jonah&quot;)
	when (employee) {
		is Employee.Manager -&gt; println(&quot;Manager: ${employee.name}, Age: ${employee.age}&quot;)
		is Employee.SeniorDev -&gt; println(&quot;SeniorDev: ${employee.name}&quot;)
	}
}
</code></pre>
<p>Here is the Rust equivalent of the Kotlin code above.</p>
<pre><code class="language-Rust">enum Employee {
    Manager { name: String, age: u8 },
    SeniorDev { name: String },
}

fn main() {
    let employee = Employee::SeniorDev { name: &quot;Jonah&quot;.to_string() };
    match employee {
        Employee::Manager { name, age } =&gt; println!(&quot;Manager: {}, Age: {}&quot;, name, age),
        Employee::SeniorDev { name } =&gt; println!(&quot;SeniorDev: {}&quot;, name),
    }
}
</code></pre>
<p>Sealed classes is an exciting feature because it gives programmers more flexibility in modelling data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-class"><a class="header" href="#inline-class">Inline class</a></h1>
<p><a href="https://kotlinlang.org/docs/inline-classes.html">Inline classes</a> are used to wrap a type.</p>
<p>One possible use case is to provide encapsulation (of the underlying type) as well as a guarantee that the right type of value is supplied at compile time. This use case is similar to Rust's <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html">newtype pattern</a>.</p>
<p>This makes inline classes more superior compared to typealiases.</p>
<p>For example, we would want the second <code>greet</code> to fail (because it's a <code>String</code>). But it's still compilable.</p>
<pre><code class="language-kotlin">typealias User = String

fun greet(user: User) {
    println(&quot;Hello, $user&quot;)
}

fun main() {
    val user: User = &quot;Raimi&quot;
    val nonUser: String = &quot;Rogue&quot;
    greet(user)
    greet(nonUser)
}
</code></pre>
<p>If we use an inline class to wrap the <code>String</code> type, there is type safety for its instances. So the following won't compile because of type mismatch:</p>
<pre><code class="language-kotlin">@JvmInline
value class User(val name: String)

fun greet(user: User) {
    println(&quot;Hello, $user&quot;)
}

fun main() {
    val user: User = User(&quot;Raimi&quot;)
    val nonUser: String = &quot;Rogue&quot;
    greet(user)
    greet(nonUser)
}
</code></pre>
<p>Another use case of inline classes is to override the <code>toString</code> method for sensitive data:</p>
<pre><code class="language-kotlin">@JvmInline
value class Password(val str: String) {
    override fun toString(): String {
        return &quot;***&quot;
    }
}

fun main() {
    val password = Password(&quot;secret&quot;)
    println(&quot;This is my password: $password&quot;)
}
</code></pre>
<div id="admonition-multiple-properties" class="admonition admonish-bug">
<div class="admonition-title">
<p>Multiple properties</p>
<p><a class="admonition-anchor-link" href="classes-and-objects/inline-class.html#admonition-multiple-properties"></a></p>
</div>
<div>
<p>Note that inline classes only work for a single property (initialised in the primary constructor). The following won't compile because it has two properties:</p>
<pre><code class="language-kotlin">@JvmInline
value class SecureString(val str: String, val numChars: Int)

fun main() {
    val password = SecureString(&quot;pa55w0rd&quot;, 1)
    println(password)
}
</code></pre>
</div>
</div>
<div id="admonition-with-sealed-classes" class="admonition admonish-bug">
<div class="admonition-title">
<p>With sealed classes</p>
<p><a class="admonition-anchor-link" href="classes-and-objects/inline-class.html#admonition-with-sealed-classes"></a></p>
</div>
<div>
<p>Inline classes don't play well with sealed classes:</p>
<pre><code class="language-kotlin">sealed class User {
    @JvmInline value class Student(val name: String): User()
    @JvmInline value class Teacher(val name: String): User()
}

fun main() {
    val user = User.Student(&quot;Raimi&quot;)
    println(user)
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-time-constants"><a class="header" href="#compile-time-constants">Compile-time constants</a></h1>
<p>Compile-time constants must be <code>String</code> or primitive type.</p>
<ul>
<li>as a top-level property</li>
<li>in an object declaration</li>
<li>in a companion object</li>
</ul>
<p>At compile-time, the compiler will inline all usages of the constant with its actual value.</p>
<p>As a top-level property</p>
<pre><code class="language-kotlin">const val NAME = &quot;Remy&quot;

fun main() {
    println(NAME)
}
</code></pre>
<p>In an object declaration</p>
<pre><code class="language-kotlin">object Person {
    const val NAME = &quot;Remy&quot;
}

fun main() {
    println(Person.NAME)
}
</code></pre>
<p>In a companion object</p>
<pre><code class="language-kotlin">class Person {
    companion object {
        const val NAME = &quot;Remy&quot;
    }
}

fun main() {
    println(Person.NAME)
}
</code></pre>
<p>These values <em>must be known</em> at compile-time. The following will fail:</p>
<pre><code class="language-kotlin">fun someName() = &quot;Remy&quot;

const val NAME = someName()

fun main() {
    println(NAME)
}
</code></pre>
<p>Some functions work, however, due to <em>const evaluation</em>:</p>
<pre><code class="language-kotlin">const val CHARACTER = &quot;Hello&quot;.get(0)

fun main() {
    println(CHARACTER)
}
</code></pre>
<p>If we look at the <code>get</code> method we see the annotation <code>@kotlin.internal.IntrinsicConstEvaluation</code>:</p>
<pre><code class="language-kotlin">@kotlin.internal.IntrinsicConstEvaluation
public override fun get(index: Int): Char
</code></pre>
<p>Documentation for <code>IntrinsicConstEvaluation</code>:</p>
<pre><code class="language-kotlin">/**
 * When applied to a function or property, enables a compiler optimization that evaluates that function or property
 * at compile-time and replaces calls to it with the computed result.
 */
@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY)
@Retention(AnnotationRetention.BINARY)
@SinceKotlin(&quot;1.7&quot;)
internal annotation class IntrinsicConstEvaluation
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-handling"><a class="header" href="#exception-handling">Exception handling</a></h1>
<div class="table-wrapper"><table><thead><tr><th>API</th><th>Client code handling</th><th>Enforced?</th></tr></thead><tbody>
<tr><td><code>throw</code> expression</td><td><code>try</code>/<code>except</code></td><td>No</td></tr>
<tr><td>Nullable return type</td><td>Type system</td><td>Yes, by the type system</td></tr>
<tr><td>Sealed class return type</td><td>Type system</td><td>Yes, by the type system</td></tr>
</tbody></table>
</div>
<p>The sealed class idiom can be seen in the standard library's <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/"><code>Result</code></a> or Arrow's <a href="https://arrow-kt.io/docs/apidocs/arrow-core/arrow.core/-either/"><code>Either</code></a>.</p>
<blockquote>
<p>‚ö†Ô∏è Take note that the compiler doesn't enforce catching exceptions thrown by libraries.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<p>Property</p>
<pre><code class="language-kotlin">val String.someChar: Char
	get() {
		return 'X'
	}

fun main() {
	println(&quot;hello&quot;.someChar)
}
</code></pre>
<p>Companion object</p>
<pre><code class="language-kotlin">class SomeClass {
	companion object {}
}

fun SomeClass.Companion.someFunction(): String {
	return &quot;dd&quot;
}

fun main() {
	println(SomeClass.someFunction())
}
</code></pre>
<p>This won't work if there isn't an existing companion object</p>
<pre><code class="language-kotlin">class SomeClass

fun SomeClass.Companion.someFunction(): String {
	return &quot;dd&quot;
}

fun main() {
	println(SomeClass.Companion.someFunction())
}
</code></pre>
<p>Anything</p>
<pre><code class="language-kotlin">fun Any?.someMethod() = &quot;hello&quot;

fun main() {
	val num = 5
	println(num.someMethod())
}
</code></pre>
<blockquote>
<p>I personally won't do this, because how are you going to test this for all the different types?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Example 1</p>
<pre><code class="language-kotlin">data class Box&lt;T&gt;(val item: T)

fun main() {
    val box = Box(10)
    println(box)
}
</code></pre>
<p>Example 2</p>
<pre><code class="language-kotlin">fun &lt;T&gt; printItem(type: T): String {
    return when (type) {
        is Int -&gt; &quot;Int&quot;
        is String -&gt; &quot;String&quot;
        else -&gt; &quot;everything else&quot;
    }
}

fun main() {
    println(printItem(10))
    println(printItem(&quot;Hello&quot;))
}
</code></pre>
<p>Example 3</p>
<pre><code class="language-kotlin">data class Box&lt;S, T&gt;(
    val item1: S,
    val item2: T,
)

fun main() {
    val box = Box(10, &quot;100&quot;)
    println(box)
}
</code></pre>
<p>Example 4</p>
<pre><code class="language-kotlin">class Box&lt;S, T&gt;(
    private val item1: S,
    private val item2: T,
) {
    fun getItem1(): S {
        return item1
    }
    fun getItem2(): T {
        return item2
    }
}

fun main() {
    val box = Box(10, &quot;item2&quot;)
    println(box)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upper-bounds"><a class="header" href="#upper-bounds">Upper bounds</a></h1>
<p>The default upper bound is <code>Any?</code>.</p>
<p>Some upper bounds (defined in the standard library) that we can use are: <code>Number</code>, <code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code> and <code>Collection&lt;T&gt;</code>.</p>
<p>Imo, I think it's always good to specify an upper bound for additional type safety (by enforcing constraints on the type parameter).</p>
<h2 id="single-upper-bound"><a class="header" href="#single-upper-bound">Single upper bound</a></h2>
<p>We can use the <code>Box&lt;T: Minimisable&gt;(...)</code> idiom:</p>
<pre><code class="language-kotlin">interface Minimisable {
    fun minimise(): Int
}

class Box&lt;T: Minimisable&gt;(val item: T) {
    fun getMinimisedItem(): Int {
        return item.minimise()
    }
}

fun main() {
    val item = object : Minimisable {
        override fun minimise(): Int {
            return 100
        }
    }
    val box = Box(item)
    println(box)
}
</code></pre>
<p>or the <code>Box&lt;T&gt;(...) where T: Minimisable</code> idiom:</p>
<pre><code class="language-kotlin">interface Minimisable {
    fun minimise(): Int
}

class Box&lt;T&gt;(val item: T) where T: Minimisable {
    fun getMinimisedItem(): Int {
        return item.minimise()
    }
}

fun main() {
    val item = object : Minimisable {
        override fun minimise(): Int {
            return 100
        }
    }
    val box = Box(item)
    println(box)
}
</code></pre>
<h2 id="multiple-upper-bounds"><a class="header" href="#multiple-upper-bounds">Multiple upper bounds</a></h2>
<p>For multiple upper bounds, only the <code>Box&lt;T&gt;(...) where T: Minimisable, Maximisable</code> syntax is valid:</p>
<pre><code class="language-kotlin">interface Minimisable {
    fun minimise(): Int
}

interface Maximisable {
    fun maximise(): Int
}

class Box&lt;T&gt;(private val item: T)
    where T: Minimisable, T: Maximisable
{
    fun getMinimisedItem(): Int {
        return item.minimise()
    }
}

class Stuff: Minimisable, Maximisable {
    override fun minimise(): Int {
        return 5
    }
    override fun maximise(): Int {
        return 100
    }
}

fun main() {
    val item = Stuff()
    val box = Box(item)
    println(box)
}
</code></pre>
<h2 id="multiple-types-with-multiple-bounds"><a class="header" href="#multiple-types-with-multiple-bounds">Multiple types with multiple bounds</a></h2>
<pre><code class="language-kotlin">interface Minimisable {
    fun minimise(): Int
}

interface Maximisable {
    fun maximise(): Int
}

class Box&lt;S, T&gt;(
    private val item1: S,
    private val item2: T,
)
    where S: Minimisable, S: Maximisable, T: Maximisable
{
    fun getItem1(): S {
        return item1
    }

    fun getItem2(): T {
        return item2
    }
}

class Stuff: Minimisable, Maximisable {
    override fun minimise(): Int {
        return 5
    }
    override fun maximise(): Int {
        return 100
    }
}

fun main() {
    val item = Stuff()

    val it = object : Maximisable {
        override fun maximise(): Int {
            return 10
        }
    }

    val box = Box(item, it)
    println(box)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-erasure"><a class="header" href="#type-erasure">Type erasure</a></h1>
<p>Type erasure is perhaps a misnomer.</p>
<p>All possible forms of a generic type will be reduced to a simple raw type after compilation. This reduction is known as <em>type erasure</em>. What this means is that <code>List&lt;String&gt;</code> and <code>List&lt;Int&gt;</code> will be <code>List</code> at runtime.</p>
<p>So this would work:</p>
<pre><code class="language-kotlin">class Box(private val name: String) {
    companion object {
        fun &lt;T&gt; from(value: T): Box {
            return when (value) {
                is Double -&gt; Box(&quot;Double&quot;)
                else -&gt; Box(&quot;Not double&quot;)
            }
        }
    }
    override fun toString(): String {
        return &quot;Box(\&quot;$name\&quot;)&quot;
    }
}

fun main() {
    println(Box.from(5))
    println(Box.from(&quot;Hello&quot;))
}
</code></pre>
<p>But it will not compile here, because of the type erasure behaviour:</p>
<pre><code class="language-kotlin">class Item&lt;T&gt;(value: T)

class Box(private val name: String) {
    companion object {
        fun &lt;T&gt; from(value: T): Box {
            return when (value) {
                is Item&lt;T&gt; -&gt; Box(&quot;Generics&quot;)  // this line is problematic!
                else -&gt; Box(&quot;Not generics&quot;)
            }
        }
    }
    override fun toString(): String {
        return &quot;Box(\&quot;$name\&quot;)&quot;
    }
}

fun main() {
    println(Box.from(Item(1000)))
    println(Box.from(&quot;Hello&quot;))
}
</code></pre>
<p>Change <code>Item&lt;T&gt;</code> to <code>Item&lt;*&gt;</code> and it works!</p>
<pre><code class="language-kotlin">class Item&lt;T&gt;(value: T)

class Box(private val name: String) {
    companion object {
        fun &lt;T&gt; from(value: T): Box {
            return when (value) {
                is Item&lt;*&gt; -&gt; Box(&quot;Generics&quot;)  // change this line
                else -&gt; Box(&quot;Not generics&quot;)
            }
        }
    }
    override fun toString(): String {
        return &quot;Box(\&quot;$name\&quot;)&quot;
    }
}

fun main() {
    println(Box.from(Item(1000)))
    println(Box.from(&quot;Hello&quot;))
}
</code></pre>
<p>Notice the decompiled Java for the <code>Item&lt;T&gt;</code> class - it doesn't have any information about the type <code>T</code> at all!</p>
<pre><code class="language-java">public final class Item {
   public Item(Object value) {}
}
</code></pre>
<p>Let's look at the decompiled Java code for creating the objects:</p>
<pre><code class="language-java">public static final void main() {
    Box var0 = Box.Companion.from(new Item(1000));
    System.out.println(var0);
    var0 = Box.Companion.from(&quot;Hello&quot;);
    System.out.println(var0);
}
</code></pre>
<p>The <code>from</code> function only checks for the &quot;outermost&quot; instance, which is either <code>Item</code> or not:</p>
<pre><code class="language-java">public final class Box {

    private final String name;

    public static final class Companion {
        public final Box from(Object value) {
            return value instanceof Item ? new Box(&quot;Generics&quot;) : new Box(&quot;Not string&quot;);
        }
    }

    // omitted for brevity
}
</code></pre>
<p>Need to use <code>reified</code>. Used together with <code>inline</code>.</p>
<pre><code class="language-kotlin">class Item&lt;T&gt;(value: T) {
    inline fun accessValue(): T
}

class Box(private val name: String) {
    companion object {
        fun &lt;T&gt; from(value: T): Box {
            return when (value) {
                is Item&lt;*&gt; -&gt; Box(&quot;Generics&quot;)  // change this line
                else -&gt; Box(&quot;Not generics&quot;)
            }
        }
    }
    override fun toString(): String {
        return &quot;Box(\&quot;$name\&quot;)&quot;
    }
}

fun main() {
    println(Box.from(Item(1000)))
    println(Box.from(&quot;Hello&quot;))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<h2 id="class-reference"><a class="header" href="#class-reference">Class reference</a></h2>
<p>A class reference has the type <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/"><code>KClass</code></a> with properties like:</p>
<ul>
<li><code>java</code> - runtime Java class reference</li>
<li><code>javaClass</code> runtime Java class of an object</li>
<li><code>qualifiedName</code></li>
</ul>
<pre><code class="language-kotlin">class Person(name: String, age: Int) {
    fun laugh() { 
        println(&quot;haha&quot;)
    }
}

fun main() {
    val klass = Person::class
    println(klass.java)
    // println(klass.javaClass)
    println(klass.qualifiedName)
    println(klass.simpleName)
    println(klass.members)
    // println(klass.declaredMemberProperties)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-and-non-local-return"><a class="header" href="#local-and-non-local-return">Local and non-local return</a></h1>
<p>Local return vs. non-local return in lambda function &amp; anonymous function</p>
<p>When you <code>return</code> from a lambda, you do a non-local (non-lambda) return, i.e. return to the function (eg. main()) which called <code>someFunction</code>. </p>
<p>Another way to look at this is this means that the <code>return</code> belongs to <code>someFunction</code>.</p>
<pre><code class="language-kotlin">fun someFunction() {

    val numbers = 1..10

    numbers.forEach {
        if (it % 5 == 0)
            return  // this return 'belongs' to someFunction
        println(&quot;Hello $it&quot;)
    }
}

someFunction()
</code></pre>
<p>This is the same as <code>return@someFunction</code>.</p>
<pre><code class="language-kotlin">fun someFunction() {
    val numbers = 1..10

    numbers.forEach {
        if (it % 5 == 0)
            return@someFunction
        println(&quot;Hello $it&quot;)
    }
}

someFunction()
</code></pre>
<p>However, if you <code>return</code> from an anonymous function, you do a local return (return to this anonymous function) (to <code>someFunction2</code>).</p>
<pre><code class="language-kotlin">fun someFunction2() {
    val numbers = 1..10

    numbers.forEach(fun(x) {
        if (x % 5 == 0)
            return  // this does not belong to someFunction2
        println(&quot;Hello $x&quot;)
    })
}

someFunction2()
</code></pre>
<p>Unless of course you specify that you want to do a non-local return.</p>
<pre><code class="language-kotlin">fun someFunction2() {
    val numbers = 1..10

    numbers.forEach(fun(x) {
        if (x % 5 == 0)
            return@someFunction2  // this 'belongs' to someFunction2
        println(&quot;Hello $x&quot;)
    })
}

someFunction2()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-interoperability"><a class="header" href="#java-interoperability">Java interoperability</a></h1>
<h2 id="named-arguments"><a class="header" href="#named-arguments">Named arguments</a></h2>
<p>Not supported when calling Java code.</p>
<h2 id="platform-types"><a class="header" href="#platform-types">Platform types</a></h2>
<p><a href="https://kotlinlang.org/docs/java-interop.html#notation-for-platform-types">Notation for platform types</a></p>
<ul>
<li><code>T!</code> = <code>T</code> or <code>T?</code></li>
<li><code>(Mutable)Collection&lt;T&gt;!</code> = <code>Collection&lt;T&gt;</code> or <code>Collection&lt;T&gt;?</code> or <code>MutableCollection&lt;T&gt;</code> or <code>MutableCollection&lt;T&gt;?</code></li>
<li><code>Array&lt;(out) T&gt;!</code> = <code>Array&lt;T&gt;</code> or <code>Array&lt;T&gt;?</code> where <code>T</code> can be a subtype</li>
</ul>
<p>Example</p>
<pre><code class="language-kotlin noplayground">import org.springframework.http.HttpHeaders

val requestHeader = HttpHeaders()
val headerValue = requestHeader[&quot;header-key&quot;]
</code></pre>
<p>where the notation of <code>headerValue</code> is given by <code>(Mutable)List&lt;String!&gt;?</code>. This means it is one of the following üò≤:</p>
<ul>
<li><code>List&lt;String&gt;?</code></li>
<li><code>List&lt;String?&gt;?</code></li>
<li><code>MutableList&lt;String&gt;?</code></li>
<li><code>MutableList&lt;String?&gt;?</code></li>
</ul>
<h2 id="static"><a class="header" href="#static">Static</a></h2>
<p>Previously</p>
<pre><code class="language-kotlin">object Utils {
    fun doSomething() {
        // logic here
    }
}
</code></pre>
<p>But if we </p>
<pre><code class="language-kotlin">object Utils {

    @JvmStatic
    fun doSomething() {
        // logic here
    }
}
</code></pre>
<p>JvmOverloads</p>
<p>such that in Java</p>
<pre><code class="language-java">Utils.INSTANCE.doSomething();
</code></pre>
<p>then in Java</p>
<pre><code class="language-java">Utils.doSomething();
</code></pre>
<h2 id="inline"><a class="header" href="#inline">Inline</a></h2>
<p><code>@JvmInline</code></p>
<p>An <code>inline</code> function with <code>reified</code> is not callable from Java.</p>
<h2 id="java-records"><a class="header" href="#java-records">Java records</a></h2>
<p>Available in JDK 16</p>
<pre><code class="language-kotlin noplayground">@JvmRecord
data class User(val name: String, val age: Int)

fun main() {
    val user = User(name = &quot;Me&quot;, age = 27)
    println(user)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gotchas"><a class="header" href="#gotchas">Gotchas</a></h1>
<ul>
<li>
<p>Unsafe cast</p>
</li>
<li>
<p>Unhandled exceptions in Kotlin collections</p>
</li>
<li>
<p>Platform types</p>
</li>
<li>
<p>1..10 iteration inclusive</p>
</li>
<li>
<p>Unsafe DSL</p>
</li>
<li>
<p>Bytearray to String</p>
<p>Correct way:</p>
<pre><code class="language-kotlin">var s = String(encryption.encrypt(&quot;fatcow&quot;), StandardCharsets.UTF_8)
</code></pre>
<p>&quot;The common mistake is trying to use the bytes.toString() to get the string from the bytes; The bytes.toString() only returns the address of the object in memory, NOT converting byte[] to a string!&quot;</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-design-patterns"><a class="header" href="#common-design-patterns">Common design patterns</a></h1>
<h2 id="singleton-pattern"><a class="header" href="#singleton-pattern">Singleton pattern</a></h2>
<p>The singleton pattern can be seen from the <code>object declaration</code>.</p>
<h2 id="builder-pattern"><a class="header" href="#builder-pattern">Builder pattern</a></h2>
<p>The builder pattern is common when building requests using RestTemplate clients in Spring Boot.</p>
<h2 id="dependency-injection-pattern"><a class="header" href="#dependency-injection-pattern">Dependency injection pattern</a></h2>
<p>This is very common in Spring Boot applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-std-library"><a class="header" href="#java-std-library">Java std library</a></h1>
<h2 id="serializable"><a class="header" href="#serializable">Serializable</a></h2>
<p>Serialisation is the conversion of an object into a <em>byte stream</em>, and deserialisation is the opposite.</p>
<p>To make an object serialisable, implement the <code>Serializable</code> interface</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-1"><a class="header" href="#types-1">Types</a></h1>
<h2 id="primitive-type"><a class="header" href="#primitive-type">Primitive type</a></h2>
<p><code>int</code></p>
<h2 id="boxed-type"><a class="header" href="#boxed-type">Boxed type</a></h2>
<p><code>java.lang.Integer</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java"><a class="header" href="#java">Java</a></h1>
<ul>
<li><code>.getMethod(&quot;somePropertyName&quot;)</code></li>
<li><code>.invoke(someObj, args...)</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsr"><a class="header" href="#jsr">JSR</a></h1>
<p>Java Specification Requests - Standards for the Java platform</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpa"><a class="header" href="#jpa">JPA</a></h1>
<p>Java Persistence API</p>
<p><a href="https://jcp.org/en/jsr/detail?id=338">JSR-338</a>, <a href="https://jcp.org/en/jsr/detail?id=317">JSR-317</a>, <a href="https://jcp.org/en/jsr/detail?id=220">JSR-220</a></p>
<p>JPA is a specification for ORM in Java. This specification is defined as a set of interfaces.</p>
<p>Interfaces that are part of the specs:</p>
<ul>
<li>
<p><strong>Entities and relationships</strong></p>
<p><code>@Entity</code>, <code>@Table</code>, <code>@Id</code>, <code>@GeneratedValue</code>, <code>@Column</code>, <code>@ManyToOne</code>, <code>@OneToMany</code>, <code>@ManyToMany</code>, <code>@OneToOne</code></p>
</li>
<li>
<p><strong>Querying</strong></p>
<p><code>@Query</code></p>
</li>
<li>
<p><strong>Persistence context</strong></p>
<p><code>EntityManager</code>, <code>EntityManagerFactory</code></p>
</li>
</ul>
<div id="admonition-connection-pool-management" class="admonition admonish-note">
<div class="admonition-title">
<p>Connection pool management</p>
<p><a class="admonition-anchor-link" href="jsr/jpa.html#admonition-connection-pool-management"></a></p>
</div>
<div>
<p>Connection pool management is typically not directly handled by JPA itself but by the underlying JPA provider.</p>
</div>
</div>
<div id="admonition-example" class="admonition admonish-example">
<div class="admonition-title">
<p>Example</p>
<p><a class="admonition-anchor-link" href="jsr/jpa.html#admonition-example"></a></p>
</div>
<div>
<p>Hibernate, MyBatis, EclipseLink, JOOQ</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jdbc"><a class="header" href="#jdbc">JDBC</a></h1>
<p>Java Database Connectivity</p>
<p><a href="https://jcp.org/en/jsr/detail?id=54">JSR-54</a>, <a href="https://jcp.org/en/jsr/detail?id=221">JSR-221</a></p>
<p>JDBC provides a standard API for <em>accessing</em> relational databases.</p>
<p>Examples of API:</p>
<ul>
<li>
<p><strong>Connection</strong></p>
<p><code>java.sql.DataSource</code>:</p>
<pre><code class="language-kotlin">interface Connection {
    fun createStatement(): Statement
}
</code></pre>
<p><code>javax.sql.DataSource</code>:</p>
<pre><code class="language-kotlin">interface DataSource {
    fun getConnection()
}
</code></pre>
</li>
<li>
<p><strong>Execution</strong></p>
<pre><code class="language-kotlin">interface Statement {
    fun executeQuery(): ResultSet
}
</code></pre>
<p>Others: <code>PreparedStatement</code></p>
</li>
<li>
<p><strong>Result</strong></p>
<p><code>ResultSet</code></p>
</li>
</ul>
<div id="admonition-connection-pool-management" class="admonition admonish-note">
<div class="admonition-title">
<p>Connection pool management</p>
<p><a class="admonition-anchor-link" href="jsr/jdbc.html#admonition-connection-pool-management"></a></p>
</div>
<div>
<p>JDBC doesn't provide connection pooling. </p>
<p>The JDBC API primarily focuses on providing a low-level, driver-based interface for executing SQL queries against a database. This includes creating and managing connections, but it doesn't include connection pooling out of the box.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-injection"><a class="header" href="#dependency-injection">Dependency injection</a></h1>
<h2 id="contexts-and-dependency-injection-for-java-20"><a class="header" href="#contexts-and-dependency-injection-for-java-20">Contexts and Dependency Injection for Java 2.0</a></h2>
<p><a href="https://jcp.org/en/jsr/detail?id=365">JSR-365</a></p>
<p>Includes <code>@Inject</code> specification</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation"><a class="header" href="#validation">Validation</a></h1>
<h2 id="bean-validation"><a class="header" href="#bean-validation">Bean Validation</a></h2>
<p><a href="https://jcp.org/en/jsr/detail?id=303">JSR-303</a> (Bean Validation) and <a href="https://jcp.org/en/jsr/detail?id=380">JSR-380</a> (Bean Validation 2.0)</p>
<p>package <code>javax.validation</code></p>
<ul>
<li>General ‚Äî <code>@NotEmpty</code>, <code>@NotBlank</code></li>
<li>Numbers ‚Äî <code>@Min</code></li>
<li>Dates ‚Äî <code>@Future</code>, <code>@Past</code> etc.</li>
<li>Emails ‚Äî <code>@Email</code></li>
<li>Collections ‚Äî <code>@Size</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="others"><a class="header" href="#others">Others</a></h1>
<h2 id="annotations-for-software-defect-detection"><a class="header" href="#annotations-for-software-defect-detection">Annotations for Software Defect Detection</a></h2>
<p><a href="https://jcp.org/en/jsr/detail?id=305">JSR-305</a></p>
<p>These annotations include nullness like <code>@NonNull</code> and <code>@UnderMigration</code>.</p>
<p>This can also be included in the compiler flag <code>-Xjsr305</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-plugin"><a class="header" href="#compiler-plugin">Compiler plugin</a></h1>
<ul>
<li><a href="https://kotlinlang.org/docs/all-open-plugin.html">all-open plugin</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-and-build"><a class="header" href="#compile-and-build">Compile and build</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-options"><a class="header" href="#compiler-options">Compiler options</a></h1>
<p>For JVM target:</p>
<pre><code class="language-sh">kotlinc hello.kt -include-runtime -d hello.jar
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decompile"><a class="header" href="#decompile">Decompile</a></h1>
<p>Kotlin compiled for JVM target can be decompiled.</p>
<ul>
<li>
<p>Use IntelliJ's decompiler</p>
</li>
<li>
<p><code>javap</code> ‚Äî this is part of the JDK</p>
<pre><code>kotlinc Hello.kt
</code></pre>
<p>and</p>
<pre><code>javap -c -p io.github.remykarem.Hello
</code></pre>
</li>
<li>
<p><code>jad</code></p>
</li>
</ul>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="compile-and-build/decompile.html#admonition-note"></a></p>
</div>
<div>
<p>Use <code>jar xf hello.jar</code> to extract JARs</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-options-1"><a class="header" href="#compiler-options-1">Compiler options</a></h1>
<ul>
<li><code>-language-version 1.5</code></li>
<li><code>-Xjsr305</code></li>
<li><code>-Xallow-result-return-type</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-repository"><a class="header" href="#local-repository">Local repository</a></h1>
<p>Local repository is stored in <code>~/.m2/repository</code>. You can publish there too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimisations"><a class="header" href="#optimisations">Optimisations</a></h1>
<h2 id="inline-1"><a class="header" href="#inline-1">Inline</a></h2>
<p><code>inline</code> functions make sense to be used if they are <em>higher-order functions. inline is copy-and-paste.</em> </p>
<p>Inline classes will use the <code>value</code> modifier. Use <code>@JvmInline</code> for java backends.</p>
<p><code>const</code> for compile-time constants. These are read-only properties (so it's will always be <code>const val</code>) that must be initialised with a primitive type or <code>String</code> type. Declaration is done either at top-level, member of an object declaration, or a companion object. </p>
<p><code>reified</code> for generic types, so that the type information is available during runtime. This directive is used together with the <code>inline</code> function. Java's solution for this is very verbose.</p>
<pre><code class="language-kotlin">fun &lt;T: Any&gt; doSomething(value: T, type: KClass&lt;T&gt;) {
    println(&quot;Doing something with type: ${type.simpleName}&quot;)       // OK
}
</code></pre>
<pre><code class="language-kotlin">value class Person {

}
</code></pre>
<p>but Kotlin handles it better:</p>
<pre><code class="language-kotlin">inline fun &lt;reified T&gt; doSomething(value: T) {
    println(&quot;Doing something with type: ${T::class.simpleName}&quot;)    // OK
}
</code></pre>
<p>While copying the body of an inline function, the compiler also replaces the type parameter T with the actual type argument that is specified or inferred in the function call.</p>
<h2 id="tail-recursion"><a class="header" href="#tail-recursion">Tail recursion</a></h2>
<h2 id="arrays-with-primitives"><a class="header" href="#arrays-with-primitives">Arrays with primitives</a></h2>
<p>https://kt.academy/article/ek-arrays</p>
<p>Also see JVM memory.</p>
<h2 id="java-8-to-java-9"><a class="header" href="#java-8-to-java-9">Java 8 to Java 9+</a></h2>
<p>For larger strings, Java 9+ is more space efficient. </p>
<h2 id="stringbuilder-vs-string"><a class="header" href="#stringbuilder-vs-string">StringBuilder vs. String</a></h2>
<p>If we're building a String a lot of times, use StringBuilder as Strings are immutable.</p>
<h2 id="pre-sizing-arrays"><a class="header" href="#pre-sizing-arrays">Pre-sizing arrays</a></h2>
<pre><code class="language-kotlin">val someGrowableList: MutableList&lt;String&gt; = ArrayList(1000)
</code></pre>
<h2 id="sequence"><a class="header" href="#sequence">Sequence</a></h2>
<p>https://kt.academy/article/ek-sequence</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<p>Most JVM are 64-bit JVM, i.e. address space is 8 bytes. </p>
<p>Although references are represented in 64 bits (8 bytes), <strong>compressed oops</strong> is enabled by default which would be 4 bytes.</p>
<h2 id="allocation"><a class="header" href="#allocation">Allocation</a></h2>
<h3 id="stack-allocated"><a class="header" href="#stack-allocated">Stack-allocated</a></h3>
<ul>
<li>Primitives (not boxed)</li>
<li>Value types</li>
<li>Local variables (value itself or reference)</li>
</ul>
<h3 id="heap-allocated"><a class="header" href="#heap-allocated">Heap-allocated</a></h3>
<ul>
<li>Boxed primitives</li>
<li>Class instances eg. custom classes, String, List</li>
</ul>
<h2 id="size"><a class="header" href="#size">Size</a></h2>
<h3 id="primitives"><a class="header" href="#primitives">Primitives</a></h3>
<p>The usuals. Char is 2 bytes (cos UTF-16).</p>
<h3 id="objects"><a class="header" href="#objects">Objects</a></h3>
<ul>
<li>~12 bytes ‚Äî header</li>
<li>x1 bytes ‚Äî value itself or reference to value</li>
<li>x2 bytes ‚Äî value itself or reference to value</li>
<li>... bytes</li>
<li>0-7 bytes ‚Äî alignment/padding</li>
</ul>
<h4 id="string"><a class="header" href="#string">String</a></h4>
<p>Metadata</p>
<ul>
<li>~12 bytes ‚Äî header</li>
<li>4 bytes ‚Äî reference to underlying value</li>
<li>1 byte ‚Äî encoding (in Java 9+)</li>
<li>4 bytes ‚Äî hash</li>
</ul>
<p>Underlying value</p>
<ul>
<li>~12 bytes ‚Äî header</li>
<li>4 bytes ‚Äî array length</li>
<li>x bytes ‚Äî value itself, where x = 2k (char, used in Java 8 or below) or x = k (byte; used in Java 9+), and k is the length of the string.</li>
<li>0-7 bytes ‚Äî alignment/padding</li>
</ul>
<p>Therefore, a String would roughly occupy (36 + k) bytes or (36 + 2k) bytes.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="jvm/memory.html#admonition-note"></a></p>
</div>
<div>
<p>Java 8 or below uses a character array for the underlying value, whereas Java 9+ uses a byte array for the underlying value.</p>
<p>More savings for Java 9+ than Java 8 for larger strings because of the backing array.</p>
</div>
</div>
<h4 id="primitive-array"><a class="header" href="#primitive-array">Primitive array</a></h4>
<p>eg. IntArray (Kotlin), int[] (Java)</p>
<ul>
<li>12 bytes ‚Äî header</li>
<li>4 bytes ‚Äî count</li>
<li>x bytes ‚Äî no. of items * size of each item</li>
<li>? bytes ‚Äî padding</li>
</ul>
<h4 id="object-array"><a class="header" href="#object-array">Object array</a></h4>
<p>Eg. List<T> (Kotlin), Object[] (Java)</p>
<p>Metadata</p>
<ul>
<li>12 bytes ‚Äî header</li>
<li>4 bytes ‚Äî count</li>
<li>x bytes ‚Äî no. of items * 4 bytes (size of each item pointer)</li>
<li>? bytes ‚Äî padding</li>
</ul>
<p>each boxed item</p>
<ul>
<li>12 bytes ‚Äî header</li>
<li>x bytes ‚Äî value itself</li>
<li>? bytes ‚Äî padding</li>
</ul>
<h4 id="mutablelist--arraylist"><a class="header" href="#mutablelist--arraylist">MutableList / ArrayList</a></h4>
<ul>
<li>Initial capacity of backing array is 10.</li>
<li>Object is copied to another if capacity of backing array is full.</li>
<li>Growth factor is 1.5.</li>
</ul>
<h2 id="padding"><a class="header" href="#padding">Padding</a></h2>
<p>To maintain 8-byte alignment. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
