<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="rust-tings.html">Rust tings</a></li><li class="chapter-item expanded "><a href="types/types.html"><strong aria-hidden="true">1.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.</strong> String and &str</div></li><li class="chapter-item expanded "><a href="types/vec.html"><strong aria-hidden="true">1.2.</strong> Vec&lt;T&gt;</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.3.</strong> Vec&lt;T&gt; and &[T]</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.4.</strong> Vec&lt;T&gt;, Iter&lt;T&gt; and IntoIter&lt;T&gt;</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.5.</strong> Enum</div></li><li class="chapter-item expanded "><a href="types/array.html"><strong aria-hidden="true">1.6.</strong> Array</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.7.</strong> Smart pointers</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.7.1.</strong> Box</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.7.2.</strong> Rc</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.7.3.</strong> Arc</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.7.4.</strong> Mutex</div></li></ol></li></ol></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/move_and_copy_semantics.html"><strong aria-hidden="true">2.</strong> Move and copy semantics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="move_and_copy_semantics/string.html"><strong aria-hidden="true">2.1.</strong> String</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/i32.html"><strong aria-hidden="true">2.2.</strong> i32</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/struct_string.html"><strong aria-hidden="true">2.3.</strong> Struct with String field</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/struct_u8.html"><strong aria-hidden="true">2.4.</strong> Struct with u8 field</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/struct_string_string.html"><strong aria-hidden="true">2.5.</strong> Struct with two String fields</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/vec.html"><strong aria-hidden="true">2.6.</strong> Vec&lt;String&gt;</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/iterator.html"><strong aria-hidden="true">2.7.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/and_str.html"><strong aria-hidden="true">2.8.</strong> &str</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/array_string.html"><strong aria-hidden="true">2.9.</strong> [String; 2]</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/array_i32.html"><strong aria-hidden="true">2.10.</strong> [i32; 2]</a></li><li class="chapter-item expanded "><a href="move_and_copy_semantics/vec_vec_str.html"><strong aria-hidden="true">2.11.</strong> Vec&lt;Vec&lt;&str&gt;&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">3.</strong> Execution models</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Single-threaded</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.1.</strong> Synchronous</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.2.</strong> Async I/O</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Multithreaded</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.1.</strong> OS thread</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.1.1.</strong> Thread pools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.1.2.</strong> Fork/join</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.1.3.</strong> Data parallelism</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.2.</strong> Green thread</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.2.1.</strong> Async I/O</div></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="interfacing_with_native_libraries/interfacing_with_native_libraries.html"><strong aria-hidden="true">4.</strong> Interfacing with native libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interfacing_with_native_libraries/link_to_an_existing_c_cpp_library.html"><strong aria-hidden="true">4.1.</strong> Link to an existing C/C++ library</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Build a native C/C++ library</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> SIMD programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Assembly</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> ndarrray crate</div></li></ol></li><li class="chapter-item expanded "><a href="macros/macros.html"><strong aria-hidden="true">6.</strong> Macros</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> macro_rules</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Procedural macros</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frapp√©</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-tings"><a class="header" href="#rust-tings">Rust tings</a></h1>
<p>Document my journey with this beast.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>404</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vect"><a class="header" href="#vect">Vec&lt;T&gt;</a></h1>
<ul>
<li><code>drain</code> vs. <code>into_iter</code></li>
</ul>
<p><a href="https://stackoverflow.com/questions/27882800/when-should-i-use-drain-vs-into-iter">When should I use <code>drain</code> vs <code>into_iter</code>?</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>We know this</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let ages: [i32; 2] = [25, 26];
    do_something(ages);
}

fn do_something(ages: [i32; 2]) {
    println!(&quot;Ages: {:?}&quot;, ages);
}</code></pre></pre>
<p>and we know it's copy on move because we can still call <code>println!</code> with <code>ages</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let ages: [i32; 2] = [25, 26];
    do_something(ages);
    println!(&quot;{:?}&quot;, ages);
}

fn do_something(ages: [i32; 2]) {
    println!(&quot;Ages: {:?}&quot;, ages);
}</code></pre></pre>
<p>but can we have an array of elements whose size can grow during runtime?</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let ages: [String; 2] = [&quot;25&quot;.to_string(), &quot;26&quot;.to_string()];
    do_something(ages);
}

fn do_something(ages: [String; 2]) {
    println!(&quot;Ages: {:?}&quot;, ages);
}</code></pre></pre>
<p>We can??? üò±</p>
<p>Let's see if... the array was moved or copied.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let ages: [String; 2] = [&quot;25&quot;.to_string(), &quot;26&quot;.to_string()];
    do_something(ages);
    println!(&quot;{:?}&quot;, ages);
}

fn do_something(ages: [String; 2]) {
    println!(&quot;Ages: {:?}&quot;, ages);
}</code></pre></pre>
<p>It was moved! Phew...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-and-copy-semantics"><a class="header" href="#move-and-copy-semantics">Move and copy semantics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i32"><a class="header" href="#i32">i32</a></h1>
<p>Life is much easier for types that implement the <code>Copy</code> trait, like <a href="https://doc.rust-lang.org/std/primitive.i32.html#"><code>i32</code></a>.</p>
<h3 id="-listing-2-1"><a class="header" href="#-listing-2-1">‚úÖ Listing 2-1</a></h3>
<p>Again, let's start with something simple. We create <code>age</code> and call <code>do_something</code> with it. Here, the value of <code>age</code> is copied, because the <code>i32</code> type implements the <code>Copy</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let age: i32 = 25;
    do_something(age);
}

fn do_something(age: i32) {
    println!(&quot;Hello, {}!&quot;, age);
}</code></pre></pre>
<h3 id="-listing-22"><a class="header" href="#-listing-22">‚úÖ Listing 2‚Äì2</a></h3>
<p>The value of <code>age</code> is copied again in Line 4.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let age: i32 = 25;
    do_something(age);
    println!(&quot;{}&quot;, age);
}

fn do_something(age: i32) {
    println!(&quot;Hello, {}!&quot;, age);
}</code></pre></pre>
<h3 id="-listing-23"><a class="header" href="#-listing-23">‚úÖ Listing 2‚Äì3</a></h3>
<p>We can also pass the value by reference, although <em>I think</em> it is not idiomatic.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let age: i32 = 25;
    do_something(&amp;age);
    println!(&quot;{}&quot;, age);
}

fn do_something(age: &amp;i32) {
    println!(&quot;Hello, {}!&quot;, age);
}</code></pre></pre>
<h3 id="--listing-24"><a class="header" href="#--listing-24">‚úÖ ‚ö†Ô∏è Listing 2‚Äì4</a></h3>
<p>In Line 3, we first cloned <code>age</code> before passing it to <code>do_something</code>. The program compiles, but note that the copying will be done twice - one in <code>.clone()</code>, the other is the copying when <code>age</code> goes into <code>do_something</code> scope.</p>
<p>Note that this idiom should be avoided. See Clippy lint on <strong>clone_on_copy</strong> <a href="https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy">here</a>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let age: i32 = 25;
    do_something(age.clone());
    println!(&quot;{}&quot;, age);
}

fn do_something(age: i32) {
    println!(&quot;Hello, {}!&quot;, age);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-with-string-field"><a class="header" href="#struct-with-string-field">Struct with String field</a></h1>
<p>A type can implement <code>Copy</code> if all of its components implement <code>Copy</code> (see <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html#when-can-my-type-be-copy">When can my type be <code>Copy</code>?</a>).</p>
<p>In these listings, we are concerned with the <code>Movie</code> struct which consists of one <code>String</code> field which <em>doesn't</em> implement <code>Copy</code>. As a result, <code>Movie</code> <em>cannot</em> implement <code>Copy</code>.</p>
<h3 id="-listing-3-1"><a class="header" href="#-listing-3-1">‚úÖ Listing 3-1</a></h3>
<p>Looks good so far, doesn‚Äôt it? Program compiles (ignoring the unused field warning) and we‚Äôre all happy.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[derive(Debug)]
struct Movie {
    title: String,
}

fn main() {
    let movie = Movie { 
        title: String::from(&quot;Rust&quot;)
    };
    do_something(movie);
}

fn do_something(movie: Movie) {
    println!(&quot;Movie: {:?}!&quot;, movie);
}</code></pre></pre>
<h3 id="-listing-3-2"><a class="header" href="#-listing-3-2">‚ùå Listing 3-2</a></h3>
<p>But after adding <code>println!</code>, the compiler complains that we are trying to borrow a value <code>movie</code> that has already moved into <code>do_something</code>.</p>
<p>We've seen this kind of move semantics before for <code>String</code>'s in the earlier listings.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[derive(Debug)]
struct Movie {
    title: String,
}

fn main() {
    let movie = Movie { 
        title: String::from(&quot;Rust&quot;)
    };
    do_something(movie);
    println!(&quot;Movie: {:?}&quot;, movie);
}

fn do_something(movie: Movie) {
    println!(&quot;Movie: {:?}!&quot;, movie);
}</code></pre></pre>
<p>What do we do?</p>
<h3 id="-listing-3-3"><a class="header" href="#-listing-3-3">‚úÖ Listing 3-3</a></h3>
<p>We can borrow <code>movie</code> instead of moving it.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Movie {
    title: String,
}

fn main() {
    let movie = Movie { 
        title: String::from(&quot;Rust&quot;)
    };
    do_something(&amp;movie);
    println!(&quot;Movie: {:?}&quot;, movie);
}

fn do_something(movie: &amp;Movie) {
    println!(&quot;Movie: {:?}!&quot;, movie);
}</code></pre></pre>
<h3 id="-listing-3-4"><a class="header" href="#-listing-3-4">‚úÖ Listing 3-4</a></h3>
<p>Or we can clone <code>movie</code> for <code>do_something</code>. This requires <code>Movie</code> to implement <code>Clone</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Clone)]
struct Movie {
    title: String,
}

fn main() {
    let movie = Movie { 
        title: String::from(&quot;Rust&quot;)
    };
    do_something(movie.clone());
    println!(&quot;Movie: {:?}&quot;, movie);
}

fn do_something(movie: Movie) {
    println!(&quot;Movie: {:?}!&quot;, movie);
}</code></pre></pre>
<h3 id="-listing-3-5"><a class="header" href="#-listing-3-5">‚úÖ Listing 3-5</a></h3>
<p>Or we can just switch the code around a bit without cloning, if your program allows it. Here, borrowed <code>movie</code> for <code>println!</code>, then move <code>movie</code> into <code>do_something</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Movie {
    title: String,
}

fn main() {
    let movie = Movie { 
        title: String::from(&quot;Rust&quot;)
    };
    println!(&quot;Movie: {:?}&quot;, movie);
    do_something(movie);
}

fn do_something(movie: Movie) {
    println!(&quot;Movie: {:?}!&quot;, movie);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-with-u8-field"><a class="header" href="#struct-with-u8-field">Struct with u8 field</a></h1>
<p>As mentioned previously, a type can implement <code>Copy</code> if all of its components implement <code>Copy</code>.</p>
<p>In these listings, we are concerned with the <code>Book</code> struct which consists of one <code>u8</code> field which implements the <code>Copy</code> trait. As a result, <code>Movie</code> <em>can</em> implement <code>Copy</code>.</p>
<h3 id="-listing-4-1"><a class="header" href="#-listing-4-1">‚úÖ Listing 4-1</a></h3>
<p>In this listing, everything looks normal, right?</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[derive(Debug)]
struct Book {
    id: u8,
}

fn main() {
    let book = Book { id: 1 };
    do_something(book);
}

fn do_something(book: Book) {
    println!(&quot;Book: {:?}!&quot;, book);
}</code></pre></pre>
<h3 id="-listing-4-2"><a class="header" href="#-listing-4-2">‚ùå Listing 4-2</a></h3>
<p>Until we add a <code>println!</code> statement below <code>do_something</code>. What happened?</p>
<p>Because <code>book</code> doesn't implement the <code>Copy</code> trait (or hasn't implemented it yet), Rust <em>moves</em> <code>book</code> into <code>do_something</code>. But... because <code>book</code> is moved, <code>println!</code> cannot use this value anymore.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[derive(Debug)]
struct Book {
    id: u8,
}

fn main() {
    let book = Book { id: 1 };
    do_something(book);
    println!(&quot;Book: {:?}&quot;, book);
}

fn do_something(book: Book) {
    println!(&quot;Book: {:?}!&quot;, book);
}</code></pre></pre>
<p>What can we do?</p>
<h3 id="-listing-4-3"><a class="header" href="#-listing-4-3">‚ùå Listing 4-3</a></h3>
<p>One way is to implement the <code>Copy</code> trait for Book by deriving <code>Copy</code>.</p>
<p>But‚Ä¶ we're still getting an error‚Ää-‚Ääthe trait bound <code>Book: Clone</code> is not satisfied.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[derive(Debug, Copy)]
struct Book {
    id: u8,
}

fn main() {
    let book = Book { id: 1 };
    do_something(book);
    println!(&quot;Book: {:?}&quot;, book);
}

fn do_something(book: Book) {
    println!(&quot;Book: {:?}!&quot;, book);
}</code></pre></pre>
<h3 id="-listing-4-4"><a class="header" href="#-listing-4-4">‚úÖ Listing 4-4</a></h3>
<p>If we head over to the <a href="https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstd%2Fmarker%2Ftrait.Copy.html%23whats-the-difference-between-copy-and-clone">docs</a>, it says that everything which is <code>Copy</code> must also implement <code>Clone</code> because <code>Clone</code> is a supertrait.</p>
<p>So let's implement the <code>Clone</code> trait for <code>Book</code> on top of the existing <code>Copy</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[derive(Debug, Copy, Clone)]
struct Book {
    id: u8,
}

fn main() {
    let book = Book { id: 1 };
    do_something(book);
    println!(&quot;Book: {:?}&quot;, book);
}

fn do_something(book: Book) {
    println!(&quot;Book: {:?}!&quot;, book);
}</code></pre></pre>
<h3 id="-listing-4-5"><a class="header" href="#-listing-4-5">‚úÖ Listing 4-5</a></h3>
<p>Sweet! We can also redesign our program such that <code>do_something</code> borrows <code>book</code> instead.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Book {
    id: u8,
}

fn main() {
    let book = Book { id: 1 };
    do_something(&amp;book);
    println!(&quot;Book: {:?}&quot;, book);
}

fn do_something(book: &amp;Book) {
    println!(&quot;Book: {:?}!&quot;, book);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-with-two-string-fields"><a class="header" href="#struct-with-two-string-fields">Struct with two String fields</a></h1>
<p>Can values be moved <em>out of</em> struct? ü§î</p>
<p>In this section, we'll talk about <em>partial move</em>.</p>
<h3 id="-listing-5-1"><a class="header" href="#-listing-5-1">‚úÖ Listing 5-1</a></h3>
<p>Everything looks normal so far...</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    alias: String,
}

fn main() {
    let person = Person { 
        name: &quot;John&quot;.to_string(),
        alias: &quot;Johan&quot;.to_string(),
    };
    print_alias(person.alias);
}

fn print_alias(alias: String) {
    println!(&quot;Person: {:?}!&quot;, alias);
}</code></pre></pre>
<h3 id="-listing-5-2"><a class="header" href="#-listing-5-2">‚ùå Listing 5-2</a></h3>
<p>However, in this listing, we added a print statement right after <code>print_alias</code>.</p>
<p>The program didn't compile because <code>person.alias</code> has <em>partially moved</em> into <code>print_alias</code>, but we tried to borrow <code>person</code> as a whole in the <code>println!</code> line.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[derive(Debug)]
struct Person {
    name: String,
    alias: String,
}

fn main() {
    let person = Person { 
        name: &quot;John&quot;.to_string(),
        alias: &quot;Johan&quot;.to_string(),
    };
    print_alias(person.alias);
    println!(&quot;{:?}&quot;, person);
}

fn print_alias(alias: String) {
    println!(&quot;Person: {:?}!&quot;, alias);
}</code></pre></pre>
<p>What can we do? What are the legal moves?</p>
<h3 id="-listing-5-3"><a class="header" href="#-listing-5-3">‚úÖ Listing 5-3</a></h3>
<p>It turns out that we <em>can</em> partially move fields - just make sure that we don't try to use the struct itself again later.</p>
<p>Here, we move the two fields into two different functions.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    alias: String,
}

fn main() {
    let person = Person { 
        name: &quot;John&quot;.to_string(),
        alias: &quot;Johan&quot;.to_string(),
    };
    print_alias(person.alias);
    print_name(person.name);
}

fn print_alias(alias: String) {
    println!(&quot;Alias: {:?}!&quot;, alias);
}

fn print_name(name: String) {
    println!(&quot;Name: {:?}!&quot;, name);
}</code></pre></pre>
<h3 id="-listing-5-4"><a class="header" href="#-listing-5-4">‚úÖ Listing 5-4</a></h3>
<p>We can pass these fields by reference.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    alias: String,
}

fn main() {
    let person = Person { 
        name: &quot;John&quot;.to_string(),
        alias: &quot;Johan&quot;.to_string(),
    };
    print_alias(&amp;person.alias);
    print_name(&amp;person.name);
}

fn print_alias(alias: &amp;str) {
    println!(&quot;Alias: {:?}!&quot;, alias);
}

fn print_name(name: &amp;str) {
    println!(&quot;Name: {:?}!&quot;, name);
}</code></pre></pre>
<h3 id="-listing-5-5"><a class="header" href="#-listing-5-5">‚úÖ Listing 5-5</a></h3>
<p>Or if we want to use <code>person</code> again later, we can¬†clone these values.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    alias: String,
}

fn main() {
    let person = Person { 
        name: &quot;John&quot;.to_string(),
        alias: &quot;Johan&quot;.to_string(),
    };
    print_alias(person.alias.clone());
    print_name(person.name.clone());
    println!(&quot;{:?}&quot;, person);
}

fn print_alias(alias: String) {
    println!(&quot;Alias: {:?}!&quot;, alias);
}

fn print_name(name: String) {
    println!(&quot;Name: {:?}!&quot;, name);
}</code></pre></pre>
<h3 id="-listing-5-6"><a class="header" href="#-listing-5-6">‚úÖ Listing 5-6</a></h3>
<p>Or you can move things around without having to clone. Here we first borrowed <code>person</code>, then partially moved the fields.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    alias: String,
}

fn main() {
    let person = Person { 
        name: &quot;John&quot;.to_string(),
        alias: &quot;Johan&quot;.to_string(),
    };
    println!(&quot;{:?}&quot;, person);
    print_alias(person.alias);
    print_name(person.name);
}

fn print_alias(alias: String) {
    println!(&quot;Alias: {:?}!&quot;, alias);
}

fn print_name(name: String) {
    println!(&quot;Name: {:?}!&quot;, name);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vecstring"><a class="header" href="#vecstring">Vec&lt;String&gt;</a></h1>
<p>Like <code>String</code>, <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#">Vec</a>'s are moved, because they don't implement the <code>Copy</code> trait (<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#trait-implementations">see here</a>). The same move semantics apply.</p>
<p>Vectors (and other collections for that matter) are worth talking about because there are so many semantics involved - the container itself, the elements, and the iterators.</p>
<p>We use <code>Vec</code> as an example here because it's a very common data structure for collections. Other collections that also don't implement the <code>Copy</code> trait include <code>HashMap</code> and <code>HashSet</code>. Move semantics for arrays, on the other hand, work similarly as structs in that they depend on the type of the item - but that's for another day.</p>
<ul>
<li><a href="move_and_copy_semantics/vec.html#container">Container</a></li>
<li><a href="move_and_copy_semantics/vec.html#items">Items</a></li>
</ul>
<h2 id="container"><a class="header" href="#container">Container</a></h2>
<h3 id="-listing-6-1"><a class="header" href="#-listing-6-1">‚úÖ Listing 6-1</a></h3>
<p>As always, we'll start with something happy:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    do_something(names);
}

fn do_something(names: Vec&lt;String&gt;) {
    println!(&quot;{:?}&quot;, names);
}</code></pre></pre>
<h3 id="-listing-6-2"><a class="header" href="#-listing-6-2">‚ùå Listing 6-2</a></h3>
<p>Until we add a <code>println!</code> statement after <code>do_something</code>.</p>
<p>We've seen this compiler error before for the <code>String</code> type where we try to borrow/use a value after it has been moved.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    do_something(names);
    println!(&quot;{:?}&quot;, names);
}

fn do_something(names: Vec&lt;String&gt;) {
    println!(&quot;{:?}&quot;, names);
}</code></pre></pre>
<p>What can we do?</p>
<h3 id="-listing-6-3"><a class="header" href="#-listing-6-3">‚úÖ Listing 6-3</a></h3>
<p>We can borrow <code>names</code> first, so that we can move it into <code>do_something</code> afterwards.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    println!(&quot;{:?}&quot;, names);
    do_something(names);
}

fn do_something(names: Vec&lt;String&gt;) {
    println!(&quot;{:?}&quot;, names);
}</code></pre></pre>
<h3 id="-listing-6-4"><a class="header" href="#-listing-6-4">‚úÖ Listing 6-4</a></h3>
<p>We can redesign <code>do_something</code> to borrow <code>names</code>so that we can borrow it again at <code>println!</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    do_something(&amp;names);
    println!(&quot;{:?}&quot;, names);
}

fn do_something(names: &amp;[String]) {
    println!(&quot;{:?}&quot;, names);
}</code></pre></pre>
<h3 id="-listing-6-5"><a class="header" href="#-listing-6-5">‚úÖ Listing 6-5</a></h3>
<p>Lastly, we can clone the vector for <code>do_something</code>. Note that vector clones are shallow copies.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    do_something(names.clone());
    println!(&quot;{:?}&quot;, names);
}

fn do_something(names: Vec&lt;String&gt;) {
    println!(&quot;{:?}&quot;, names);
}</code></pre></pre>
<h2 id="items"><a class="header" href="#items">Items</a></h2>
<p>Reading elements in a vector via getting the index is tricky. It's just not the same in the programming languages that we know.</p>
<h3 id="-listing-6-6"><a class="header" href="#-listing-6-6">‚ùå Listing 6-6</a></h3>
<p>I mean would you take a look at this! The code below is perfectly fine in the programming languages that I know but here, we get a compiler error saying I cannot move out of index of <code>Vec&lt;String&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    let name: String = names[0];
    println!(&quot;Hello, {}&quot;, name);
}</code></pre></pre>
<p>But why?</p>
<p>See, if you move only one element out of a <code>Vec</code>, you leave the vector in an <strong>invalid state</strong> - the vector is not a collection of homogenous elements anymore</p>
<p>Implicitly moving out of a <code>Vec</code> is not allowed as it would <strong>leave the vector in an invalid state</strong>‚Ää-‚Ääone element is moved out, the others are not (see <a href="https://stackoverflow.com/questions/27904864/what-does-cannot-move-out-of-index-of-mean">this</a> StackOverflow post). If I were to iterate this vector, I might access an invalid memory (the element that was moved out) üò±. Thanks for protecting us, Rust.</p>
<p>So what do we do?</p>
<h3 id="-listing-6-7"><a class="header" href="#-listing-6-7">‚úÖ Listing 6-7</a></h3>
<p>We can <em>borrow</em> the value that we want by using the indexing operator.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    let name: &amp;str = &amp;names[0];
    println!(&quot;Hello, {}&quot;, name);
}</code></pre></pre>
<h3 id="-listing-6-8"><a class="header" href="#-listing-6-8">‚úÖ Listing 6-8</a></h3>
<p>We can also <em>borrow</em> the value using the <code>.get</code> method.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    let name: &amp;str = names.get(0).unwrap();
    println!(&quot;Hello, {}&quot;, name);
}</code></pre></pre>
<h3 id="-listing-6-9"><a class="header" href="#-listing-6-9">‚úÖ Listing 6-9</a></h3>
<p>We can also <em>borrow</em> the value using the <code>.first()</code> or¬†<code>.last()</code> method (if you want the first and last item, of course).</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    let name: &amp;str = names.first().unwrap();
    println!(&quot;Hello, {}&quot;, name);
}</code></pre></pre>
<p>But... what if I want to <em>own</em> an element?</p>
<h3 id="-listing-6-10"><a class="header" href="#-listing-6-10">‚úÖ Listing 6-10</a></h3>
<p>We use the <code>.into_iter()</code> method to own the individual elements. More on iterators in the next chapter.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    let mut names_iter = names.into_iter();
    let name: String = names_iter.next().unwrap();
    println!(&quot;Hello, {}&quot;, name);
}</code></pre></pre>
<p>This example works if you want to own the first element. Afaik, if you want to own the element at index <em>n</em> (for some reason), you would call <code>.skip(n)</code> then call <code>.next()</code>.</p>
<h3 id="-listing-6-11"><a class="header" href="#-listing-6-11">‚úÖ Listing 6-11</a></h3>
<p>For <code>Vec</code>, we can <code>.pop()</code> the last element and own the data.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut names = vec![String::from(&quot;John&quot;), String::from(&quot;Jane&quot;)];
    let name: String = names.pop().unwrap();
    println!(&quot;Hello, {}&quot;, name);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p><a href="https://doc.rust-lang.org/std/iter/index.html">Iterators</a> play an extremely important role when it comes to ownership of elements in a collection.</p>
<p>In these examples we will use <code>Vec&lt;String&gt;</code>, intentionally using <code>String</code> as the element (which does not implement the <code>Copy</code> trait) so that we can demonstrate its move semantics in a vector.</p>
<p>https://doc.rust-lang.org/nightly/std/iter/#for-loops-and-intoiterator</p>
<ul>
<li><a href="move_and_copy_semantics/iterator.html#for-loop">for-loop</a></li>
<li><a href="move_and_copy_semantics/iterator.html#functional-programming">Functional programming</a></li>
<li><a href="move_and_copy_semantics/iterator.html#functional-programming">Iter::next</a></li>
</ul>
<h2 id="for-loop"><a class="header" href="#for-loop">for-loop</a></h2>
<h3 id="-listing-7-1"><a class="header" href="#-listing-7-1">‚úÖ Listing 7-1</a></h3>
<p>Let's start with a for-loop iterating over <code>names</code>. Why for-loop? We'll get to that.</p>
<p>But for now, life's a bed of roses:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];

    for name in names {
        println!(&quot;{}&quot;, name);
    }
}</code></pre></pre>
<h3 id="-listing-7-2"><a class="header" href="#-listing-7-2">‚ùå Listing 7-2</a></h3>
<p>Until we add a print statement below the for-loop... where the compiler starts to complain.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];

    for name in names {
        println!(&quot;{}&quot;, name);
    }

    println!(&quot;Names: {:?}&quot;, names);
}</code></pre></pre>
<p>Apparently there is an &quot;implicit¬†<code>.into_iter</code> call before the loop.&quot;</p>
<p>Wait, <em>implicit</em>? Why?! But okay, let's add that implicit <code>.into_iter</code>:</p>
<h3 id="-listing-7-3"><a class="header" href="#-listing-7-3">‚ùå Listing 7-3</a></h3>
<p>After adding <code>into_iter()</code>, we expect that the program still does not compile.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];

    for name in names.into_iter() {
        println!(&quot;{}&quot;, name);
    }

    println!(&quot;Names: {:?}&quot;, names);
}</code></pre></pre>
<h3 id="-listing-7-4"><a class="header" href="#-listing-7-4">‚ùå Listing 7-4</a></h3>
<p>Hmmmmm let‚Äôs assign a variable to <code>names.into_iter()</code>. So that we can sort of visualise the move. Note that we still expect the program to not compile.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];

    let names_iter = names.into_iter();

    for name in names_iter {
        println!(&quot;{}&quot;, name);
    }

    println!(&quot;Names: {:?}&quot;, names);
}</code></pre></pre>
<p>What's happening is that using <code>into_iter</code>, we are <em>moving</em> the elements from <code>names</code> into <code>names_iter</code>. As a result, we cannot use <code>names</code> anymore!</p>
<p>What do we do?</p>
<h3 id="-listing-7-5"><a class="header" href="#-listing-7-5">‚úÖ Listing 7-5</a></h3>
<p>We can borrow elements from <code>names</code> using <code>.iter()</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];

    for name in names.iter() {
        println!(&quot;{}&quot;, name);
    }

    println!(&quot;Names: {:?}&quot;, names);
}</code></pre></pre>
<h3 id="-listing-7-6"><a class="header" href="#-listing-7-6">‚úÖ Listing 7-6</a></h3>
<p>We can use a slice (which implements <code>IntoIterator</code>).</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];

    for name in &amp;names {
        println!(&quot;{}&quot;, name);
    }

    println!(&quot;Names: {:?}&quot;, names);
}</code></pre></pre>
<h3 id="-listing-7-7"><a class="header" href="#-listing-7-7">‚úÖ Listing 7-7</a></h3>
<p>If your program allows it, we can switch the code around a bit to borrow <code>names</code> first, then move it:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];

    println!(&quot;Names: {:?}&quot;, names);

    for name in names {
        println!(&quot;{}&quot;, name);
    }
}</code></pre></pre>
<h3 id="-listing-7-8"><a class="header" href="#-listing-7-8">‚úÖ Listing 7-8</a></h3>
<p>We can also clone the vector. Note that there are costs to cloning.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];

    for name in names.clone() {
        println!(&quot;{}&quot;, name);
    }

    println!(&quot;Names: {:?}&quot;, names);
}</code></pre></pre>
<h2 id="functional-programming"><a class="header" href="#functional-programming">Functional programming</a></h2>
<p>Using functional programming idioms makes it more obvious that iterators are involved when you want to iterate over elements (especially if you come from programming languages where you don't have to deal with iterators directly).</p>
<p>Unlike for-loops, there are no implicit <code>.into_iter()</code> calls. As such, for vectors, we always need to call <code>.iter()</code>, <code>.into_iter()</code>, etc. to get an iterator.</p>
<h3 id="-listing-7-9"><a class="header" href="#-listing-7-9">‚ùå Listing 7-9</a></h3>
<p>Here it doesn't compile because we need to iterate over the elements, meaning we need get an iterator using, say, <code>.iter()</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];
    
    names.for_each(|name| println!(&quot;{}&quot;, name));
    
    println!(&quot;{:?}&quot;, names);
}</code></pre></pre>
<h3 id="-listing-7-10"><a class="header" href="#-listing-7-10">‚úÖ Listing 7-10</a></h3>
<p>Here, we use a combination of <code>.iter()</code> and <code>.for_each()</code>.</p>
<p>The iterator returns a reference to the elements. We can still use the <code>names</code> object afterward:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];
    
    names
        .iter()
        .for_each(|name| println!(&quot;{}&quot;, name));
    
    println!(&quot;{:?}&quot;, names);
}</code></pre></pre>
<h3 id="-listing-7-11"><a class="header" href="#-listing-7-11">‚ùå Listing 7-11</a></h3>
<p>If you want to move the elements, use <code>.into_iter()</code>. However, note that we can't use the vector afterwards:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];
    
    names
        .into_iter()
        .for_each(|name| println!(&quot;{}&quot;, name));
    
    println!(&quot;{:?}&quot;, names); 
}</code></pre></pre>
<h3 id="-listing-7-12"><a class="header" href="#-listing-7-12">‚úÖ Listing 7-12</a></h3>
<p>You'll need to redesign your program such that you don't use the moved elements. Here, we moved the print statement in front:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];
    
    println!(&quot;{:?}&quot;, names); 

    names
        .into_iter()
        .for_each(|name| println!(&quot;{}&quot;, name));
}</code></pre></pre>
<h3 id="-listing-7-13"><a class="header" href="#-listing-7-13">‚úÖ Listing 7-13</a></h3>
<p>We could also clone the vector before calling <code>.into_iter()</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![String::from(&quot;John&quot;),String::from(&quot;Jane&quot;)];

    names.clone()
        .into_iter()
        .for_each(|name| println!(&quot;{}&quot;, name));
    
    println!(&quot;{:?}&quot;, names); 
}</code></pre></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p><strong>Do not be fooled when you see your IDE type hint <code>Iter&lt;T&gt;</code>.</strong> For <code>Iter&lt;T&gt;</code>, you are iterating over <code>&amp;T</code>, not <code>T</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="str"><a class="header" href="#str">&amp;str</a></h1>
<p>Shared references (&amp;T) are also Copy (see <a href="https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstd%2Fmarker%2Ftrait.Copy.html%23when-can-my-type-be-copy">here</a>). Here is an example of a commonly used type, the string slice <code>&amp;str</code>.</p>
<h3 id="-listing-81"><a class="header" href="#-listing-81">‚úÖ Listing 8‚Äì1</a></h3>
<p>We can pass <code>name</code> to <code>do_something</code> in Lines 3 and 4. Note that we are <em>copying</em> the reference.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let name: &amp;'static str = &quot;Rust&quot;;
    do_something(name);
    do_something(name);
}

fn do_something(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}</code></pre></pre>
<h3 id="--listing-82"><a class="header" href="#--listing-82">‚úÖ ‚ö†Ô∏è Listing 8‚Äì2</a></h3>
<p>Similar to Listing 2‚Äì4, calling¬†<code>.clone()</code> just before passing name to do_something is redundant.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let name: &amp;'static str = &quot;Rust&quot;;
    do_something(name.clone());
    do_something(name.clone());
}

fn do_something(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}</code></pre></pre>
<h3 id="--listing-83"><a class="header" href="#--listing-83">‚úÖ ‚ö†Ô∏è Listing 8‚Äì3</a></h3>
<p>Suggested by clippy, the <code>&lt;&amp;str&gt;::clone(&amp;name)</code> idiom clones the reference. The program compiles, but I'm not sure if this is idiomatic.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let name: &amp;'static str = &quot;Rust&quot;;
    do_something(&lt;&amp;str&gt;::clone(&amp;name));
    do_something(&lt;&amp;str&gt;::clone(&amp;name));
}

fn do_something(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-2"><a class="header" href="#string-2">[String; 2]</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-1"><a class="header" href="#array-1">Array</a></h1>
<h2 id="-listing-2-1-1"><a class="header" href="#-listing-2-1-1">‚úÖ Listing 2-1</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let ages: [i32; 2] = [25, 26];
    do_something(ages);
}

fn do_something(ages: [i32; 2]) {
    println!(&quot;Ages: {:?}&quot;, ages);
}</code></pre></pre>
<h2 id="-listing-22-1"><a class="header" href="#-listing-22-1">‚úÖ Listing 2‚Äì2</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let ages: [i32; 2] = [25, 26];
    do_something(ages);
    println!(&quot;{:?}&quot;, ages);
}

fn do_something(ages: [i32; 2]) {
    println!(&quot;Ages: {:?}&quot;, ages);
}</code></pre></pre>
<h2 id="-listing-23-1"><a class="header" href="#-listing-23-1">‚úÖ Listing 2‚Äì3</a></h2>
<p>We can also pass the value by reference, although it is not idiomatic.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let ages: [i32; 2] = [25, 26];
    do_something(&amp;ages);
    println!(&quot;{:?}&quot;, ages);
}

fn do_something(ages: &amp;[i32; 2]) {
    println!(&quot;Ages: {:?}&quot;, ages);
}</code></pre></pre>
<h2 id="--listing-24-1"><a class="header" href="#--listing-24-1">‚úÖ ‚ö†Ô∏è Listing 2‚Äì4</a></h2>
<p>In Line 3, we first cloned <code>ages</code> before passing it to <code>do_something</code>. The program compiles, but note that the copying will be done twice - one in <code>.clone()</code>, the other is the copying when <code>ages</code> goes into <code>do_something</code> scope.</p>
<p>Note that this idiom should be avoided. See Clippy lint on <strong>clone_on_copy</strong> <a href="https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy">here</a>.</p>
<p>Clippy will</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let ages: [i32; 2] = [25, 26];
    do_something(ages.clone());
    println!(&quot;{:?}&quot;, ages);
}

fn do_something(ages: [i32; 2]) {
    println!(&quot;Ages: {:?}&quot;, ages);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-borrow"><a class="header" href="#mutable-borrow">Mutable borrow</a></h1>
<h2 id="nested-mutable-borrow"><a class="header" href="#nested-mutable-borrow">Nested mutable borrow</a></h2>
<p>Based on <a href="https://stackoverflow.com/questions/72794937/how-to-push-additional-element-to-vecvecstring/72795527#72795527">StackOverflow post</a>.</p>
<p>How to do mutable borrow for a vector of a vector?</p>
<p>Not okay:</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">fn mutate(vec: &amp;Vec&lt;&amp;mut Vec&lt;&amp;str&gt;&gt;) {
    vec.iter_mut().for_each(|inner_vec| {
        inner_vec.push(&quot;something&quot;);
    });

    println!(&quot;{:?}&quot;, vec);
}

fn main() {
    let mut vec1 = vec![&quot;a1&quot;, &quot;b2&quot;, &quot;c3&quot;];
    let mut vec2 = vec![&quot;d1&quot;, &quot;e2&quot;, &quot;f3&quot;];
    let mut vec3 = vec![&quot;g1&quot;, &quot;h2&quot;, &quot;i3&quot;];

    let mut vec: Vec&lt;&amp;Vec&lt;&amp;str&gt;&gt; = vec![&amp;mut vec1, &amp;mut vec2, &amp;mut vec3];

    mutate(&amp;mut vec);
}</code></pre></pre>
<p>Okay:</p>
<p>We need a <code>&amp;mut Vec&lt;&amp;mut Vec&lt;&amp;str&gt;&gt;</code> type.</p>
<pre><pre class="playground"><code class="language-rust editable">fn mutate(vec: &amp;mut Vec&lt;&amp;mut Vec&lt;&amp;str&gt;&gt;) {
    vec.iter_mut().for_each(|inner_vec| {
        inner_vec.push(&quot;something&quot;);
    });

    println!(&quot;{:?}&quot;, vec);
}

fn main() {
    let mut vec1 = vec![&quot;a1&quot;, &quot;b2&quot;, &quot;c3&quot;];
    let mut vec2 = vec![&quot;d1&quot;, &quot;e2&quot;, &quot;f3&quot;];
    let mut vec3 = vec![&quot;g1&quot;, &quot;h2&quot;, &quot;i3&quot;];

    let mut vec: Vec&lt;&amp;mut Vec&lt;&amp;str&gt;&gt; = vec![
        &amp;mut vec1,
        &amp;mut vec2,
        &amp;mut vec3,
    ];

    mutate(&amp;mut vec);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfacing-with-native-libraries"><a class="header" href="#interfacing-with-native-libraries">Interfacing with native libraries</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="link-to-an-existing-cc-library"><a class="header" href="#link-to-an-existing-cc-library">Link to an existing C/C++ library</a></h1>
<p>To call external code, we need the keyword <code>extern</code> that will crreate and use FFI. FFIs are like bindings to the external library.</p>
<p>https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code</p>
<h2 id="c-standard-library"><a class="header" href="#c-standard-library">C standard library</a></h2>
<p>To call a function from the C standard library (eg.<code>abs</code>), simply:</p>
<pre><pre class="playground"><code class="language-rust editable">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}</code></pre></pre>
<h2 id="user-library"><a class="header" href="#user-library">User library</a></h2>
<p>To call a function from a library <code>libawesome.a</code> or <code>libawesome.dylib</code> which is found in <code>/usr/local/lib</code>, <code>/usr/lib</code>, <code>/Library/Developer/CommandLineTools/SDKs/**/usr/lib</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">#[link(name = &quot;awesome&quot;)]
extern &quot;C&quot; {
    // function here
}

fn main() {
    unsafe {
        // functionl call
    }
}</code></pre></pre>
<p>More info about the <code>link</code> attribute https://doc.rust-lang.org/reference/items/external-blocks.html#the-link-attribute.</p>
<p>See the dynamic library paths that Cargo sets https://doc.rust-lang.org/cargo/reference/environment-variables.html#dynamic-library-paths.</p>
<h2 id="custom-library"><a class="header" href="#custom-library">Custom library</a></h2>
<p>To call a function from a library <code>libawesome.a</code> or <code>libawesome.dylib</code> which is found elsewhere, you need to create a build script:</p>
<p><code>build.rs</code></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;cargo:rustc-link-search=/path/to/lib&quot;);
    println!(&quot;cargo:rustc-link-lib=awesome&quot;);
}</code></pre></pre>
<p><code>src/main.rs</code></p>
<pre><pre class="playground"><code class="language-rust editable">#[link(name = &quot;awesome&quot;)]
extern &quot;C&quot; {
    // function here
}

fn main() {
    unsafe {
        // functionl call
    }
}</code></pre></pre>
<h2 id="custom-library--auto-generated-ffi-bindings-from-headers"><a class="header" href="#custom-library--auto-generated-ffi-bindings-from-headers">Custom library + auto-generated FFI bindings from headers</a></h2>
<p>Refer to <a href="https://rust-lang.github.io/rust-bindgen/">bindgen</a>.</p>
<h2 id="appendix-creating-a-static-library"><a class="header" href="#appendix-creating-a-static-library">Appendix: Creating a static library</a></h2>
<p><code>hello.c</code></p>
<pre><code class="language-c">int square(int value) {
  return value * value;
}
</code></pre>
<p>Run:</p>
<pre><code class="language-sh">gcc -c -o hello.o hello.c
ar rcs libhello.a hello.o
</code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>https://doc.rust-lang.org/nomicon/ffi.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>