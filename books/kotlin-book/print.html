<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kotlin Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="java_distributions.html"><strong aria-hidden="true">1.</strong> Java distributions</a></li><li class="chapter-item expanded "><a href="std_library/std_library.html"><strong aria-hidden="true">2.</strong> Std library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_library/kotlin_std_library/kotlin_std_library.html"><strong aria-hidden="true">2.1.</strong> Kotlin std library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_library/kotlin_std_library/collections.html"><strong aria-hidden="true">2.1.1.</strong> Collections</a></li><li class="chapter-item expanded "><a href="std_library/kotlin_std_library/mutability.html"><strong aria-hidden="true">2.1.2.</strong> Mutability</a></li><li class="chapter-item expanded "><a href="std_library/kotlin_std_library/scope_functions.html"><strong aria-hidden="true">2.1.3.</strong> Scope functions</a></li><li class="chapter-item expanded "><a href="std_library/kotlin_std_library/use.html"><strong aria-hidden="true">2.1.4.</strong> use</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.5.</strong> Preconditions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.6.</strong> Result</div></li></ol></li><li class="chapter-item expanded "><a href="std_library/java_std_library/java_std_library.html"><strong aria-hidden="true">2.2.</strong> Java std library</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.1.</strong> Interfaces</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.2.</strong> Date and time</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.3.</strong> File I/O</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.4.</strong> Networking</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.5.</strong> Crypto</div></li></ol></li></ol></li><li class="chapter-item expanded "><a href="classes_and_objects/classes_and_objects.html"><strong aria-hidden="true">3.</strong> Classes and objects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/class.html"><strong aria-hidden="true">3.1.</strong> Class structure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/property.html"><strong aria-hidden="true">3.1.1.</strong> Property</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/property_with_getter.html"><strong aria-hidden="true">3.1.1.1.</strong> With getter</a></li><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/property_with_setter.html"><strong aria-hidden="true">3.1.1.2.</strong> With setter</a></li><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/property_with_getter_and_setter.html"><strong aria-hidden="true">3.1.1.3.</strong> With getter and setter</a></li><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/lazy_property.html"><strong aria-hidden="true">3.1.1.4.</strong> Lazy property</a></li><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/late-init_property.html"><strong aria-hidden="true">3.1.1.5.</strong> Late-init property</a></li></ol></li><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/companion_object.html"><strong aria-hidden="true">3.1.2.</strong> Companion object</a></li><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/methods.html"><strong aria-hidden="true">3.1.3.</strong> Methods</a></li><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/constructor.html"><strong aria-hidden="true">3.1.4.</strong> Constructor</a></li><li class="chapter-item expanded "><a href="classes_and_objects/class_structure/initializer_block.html"><strong aria-hidden="true">3.1.5.</strong> Initializer block</a></li></ol></li><li class="chapter-item expanded "><a href="classes_and_objects/interface.html"><strong aria-hidden="true">3.2.</strong> Interface</a></li><li class="chapter-item expanded "><a href="classes_and_objects/data_class.html"><strong aria-hidden="true">3.3.</strong> Data class</a></li><li class="chapter-item expanded "><a href="classes_and_objects/object.html"><strong aria-hidden="true">3.4.</strong> Object</a></li><li class="chapter-item expanded "><a href="classes_and_objects/data_object.html"><strong aria-hidden="true">3.5.</strong> Data object</a></li><li class="chapter-item expanded "><a href="classes_and_objects/enum_class.html"><strong aria-hidden="true">3.6.</strong> Enum class</a></li><li class="chapter-item expanded "><a href="classes_and_objects/sealed_class.html"><strong aria-hidden="true">3.7.</strong> Sealed class</a></li><li class="chapter-item expanded "><a href="classes_and_objects/value_class.html"><strong aria-hidden="true">3.8.</strong> Value class</a></li><li class="chapter-item expanded "><a href="classes_and_objects/compile-time_constants.html"><strong aria-hidden="true">3.9.</strong> Compile-time constants</a></li></ol></li><li class="chapter-item expanded "><a href="exception_handling.html"><strong aria-hidden="true">4.</strong> Exception handling</a></li><li class="chapter-item expanded "><a href="extensions.html"><strong aria-hidden="true">5.</strong> Extensions</a></li><li class="chapter-item expanded "><a href="generics/generics.html"><strong aria-hidden="true">6.</strong> Generics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/basics.html"><strong aria-hidden="true">6.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="generics/upper_bounds.html"><strong aria-hidden="true">6.2.</strong> With upper bounds</a></li><li class="chapter-item expanded "><a href="generics/type_erasure.html"><strong aria-hidden="true">6.3.</strong> With erased type</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Variance</div></li></ol></li><li class="chapter-item expanded "><a href="reflection/reflection.html"><strong aria-hidden="true">7.</strong> Reflection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reflection/kotlin.html"><strong aria-hidden="true">7.1.</strong> Kotlin</a></li><li class="chapter-item expanded "><a href="reflection/java.html"><strong aria-hidden="true">7.2.</strong> Java</a></li></ol></li><li class="chapter-item expanded "><a href="control_flow/control_flow.html"><strong aria-hidden="true">8.</strong> Control flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="control_flow/local_and_non-local_return.html"><strong aria-hidden="true">8.1.</strong> Local and non-local return</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Annotation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Concurrency</div></li><li class="chapter-item expanded "><a href="java_interoperability.html"><strong aria-hidden="true">11.</strong> Java interoperability</a></li><li class="chapter-item expanded "><a href="gotchas.html"><strong aria-hidden="true">12.</strong> Gotchas</a></li><li class="chapter-item expanded "><a href="common_design_patterns.html"><strong aria-hidden="true">13.</strong> Common design patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="common_design_patterns/singleton.html"><strong aria-hidden="true">13.1.</strong> Singleton</a></li><li class="chapter-item expanded "><a href="common_design_patterns/factory_method.html"><strong aria-hidden="true">13.2.</strong> Factory method</a></li><li class="chapter-item expanded "><a href="common_design_patterns/builder.html"><strong aria-hidden="true">13.3.</strong> Builder</a></li><li class="chapter-item expanded "><a href="common_design_patterns/prototype.html"><strong aria-hidden="true">13.4.</strong> Prototype</a></li><li class="chapter-item expanded "><a href="common_design_patterns/delegate.html"><strong aria-hidden="true">13.5.</strong> Delegate</a></li></ol></li><li class="chapter-item expanded "><a href="jsr.html"><strong aria-hidden="true">14.</strong> JSR</a></li><li class="chapter-item expanded "><a href="compile_and_build/compile_and_build.html"><strong aria-hidden="true">15.</strong> Compile and build</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compile_and_build/compile.html"><strong aria-hidden="true">15.1.</strong> Compile</a></li><li class="chapter-item expanded "><a href="compile_and_build/compiler_options.html"><strong aria-hidden="true">15.2.</strong> Compiler options</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> Gradle</div></li><li class="chapter-item expanded "><a href="local_repository.html"><strong aria-hidden="true">15.4.</strong> Local repository</a></li></ol></li><li class="chapter-item expanded "><a href="optimisations.html"><strong aria-hidden="true">16.</strong> Optimisations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kotlin Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>This Kotlin book is written mainly for the JVM target.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-distributions"><a class="header" href="#java-distributions">Java distributions</a></h1>
<p><a href="https://en.wikipedia.org/wiki/OpenJDK">OpenJDK</a> is the reference implementation of Java SE.</p>
<p>Here are the different Java distributions for the OpenJDK implementation:</p>
<div class="table-wrapper"><table><thead><tr><th>Distribution</th><th>From</th><th>LTS</th></tr></thead><tbody>
<tr><td>Eclipse Temurin</td><td>Adoptium</td><td>Yes</td></tr>
<tr><td>Amazon Corretto</td><td>Amazon</td><td>Yes</td></tr>
<tr><td>Azul Zulu</td><td>Azul Systems</td><td>Yes</td></tr>
<tr><td>Oracle OpenJDK</td><td>Oracle</td><td>No!</td></tr>
<tr><td>Oracle Java SSE</td><td>Oracle</td><td>Yes</td></tr>
<tr><td>Red Hat build of OpenJDK</td><td>Red Hat</td><td>Yes</td></tr>
<tr><td>GraalVM Community Edition</td><td>GraalVM</td><td>Yes</td></tr>
</tbody></table>
</div>
<p>TCK (Technology Compatibility Kit) is a suite of tests that checks for JSR compliance. Java distribution builds are usually TCK-tested.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="std-library"><a class="header" href="#std-library">Std library</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin-std-library"><a class="header" href="#kotlin-std-library">Kotlin std library</a></h1>
<p>Kotlin standard libraries are <code>kotlin-stdlib</code>, <code>kotlin-reflect</code> and <code>kotlin-script-*</code>.</p>
<p>As of Kotlin 1.8.0, these libraries are compiled with JVM target 1.8. As a result, the <code>kotlin-stdlib-jdk7</code> and <code>kotlin-stdlib-jdk8</code> are no longer needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p><code>asSequence</code>  generator, lazy evaluate, <code>generateSequence</code>, <code>sequenceOf</code>, <code>sequence</code>, <code>yield</code>, <code>yieldAll</code>. use terminal operations like <code>toList()</code> or <code>sum()</code> to evaluate.</p>
<blockquote>
<p>⚠️ Sequence performs all the processing steps <strong>one-by-one</strong>!</p>
</blockquote>
<blockquote>
<p>⚠️ Some overhead!</p>
</blockquote>
<ul>
<li>
<p>Array</p>
<p>Egs: Array, IntArray, CharArray, DoubleArray</p>
<ul>
<li>Data in arrays are stored in a sequential manner</li>
<li>Size is determined</li>
<li>fixed size elements</li>
<li>Cannot reassign (invariant)</li>
</ul>
</li>
<li>
<p>List</p>
<p>Read-only</p>
<ul>
<li><code>List</code>
Default implementation: ArrayList</li>
<li><code>ArrayList</code>
Resizable array</li>
</ul>
<p>M<strong>utable</strong></p>
<ul>
<li><code>MutableList</code></li>
</ul>
</li>
<li>
<p>Set</p>
<p>Read-only</p>
<ul>
<li><code>Set</code>
Default implementation: LinkedHashSet</li>
<li><code>HashSet</code>
Less memory, order not preserved</li>
<li><code>LinkedHashSet</code>
preserves order of elements insertion</li>
</ul>
<p>M<strong>utable</strong></p>
<ul>
<li><code>MutableSet</code></li>
</ul>
</li>
<li>
<p>Map</p>
<p>Read-only</p>
<ul>
<li><code>Map</code>
Default implementation: LinkedHashMap</li>
<li><code>HashMap</code>
Less memory, order not preserved</li>
<li><code>LinkedHashMap</code>
preserves order of elements insertion</li>
</ul>
<p>M<strong>utable</strong></p>
<ul>
<li><code>MutableMap</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutability"><a class="header" href="#mutability">Mutability</a></h1>
<blockquote>
<p>⚠️ <code>List</code> is not immutable. You can cast it to mutable list. Its mutability can also change if you pass to a fnction that accepts mutablelist.</p>
</blockquote>
<p>Immutable: state cannot be modified after it is created. String.</p>
<blockquote>
<p>💡 For Immutable support, use Google's Guava or JetBrain's Kotlinx Immutable Collections Library</p>
</blockquote>
<p>Mutable</p>
<p>Read-only: val, List. Compile-time</p>
<blockquote>
<p>💡 <code>val</code> means cannot reassign</p>
</blockquote>
<blockquote>
<p>💡 <code>ReadOnlyDataStructure</code> means cannot write</p>
</blockquote>
<p>Grammar</p>
<ol>
<li><code>val</code> + <code>ReadOnlyDataStructure</code>
<ul>
<li>Cannot write</li>
<li>Cannot reassign</li>
</ul>
</li>
<li><code>var</code> + <code>ReadOnlyDataStructure</code>
<ul>
<li>Cannot write</li>
<li>Can reassign</li>
</ul>
</li>
<li><code>val</code> + <code>MutableDataStructure</code>
<ul>
<li>Can write</li>
<li>Cannot reassign</li>
</ul>
</li>
<li><code>var</code> + <code>MutableDataStructure</code>
<ul>
<li>Can write</li>
<li>Can reassign</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-functions"><a class="header" href="#scope-functions">Scope functions</a></h1>
<p>There are 5 scoped functions - <code>let</code>, <code>apply</code>, <code>run</code>, <code>also</code> and <code>with</code>.</p>
<p>The only scoped functions that I use are <code>let</code> and <code>apply</code>.</p>
<h2 id="let"><a class="header" href="#let"><strong>let</strong></a></h2>
<p>For me I use the <code>let</code> idiom mainly when dealing with <code>null</code>s.</p>
<pre><pre class="playground"><code class="language-kotlin">fun printName(name: String) {
	println(name)
}

fun main() {
	val name: String? = &quot;Harry&quot;
	name?.let { printName(it) }
}</code></pre></pre>
<p>or use a function reference:</p>
<pre><pre class="playground"><code class="language-kotlin">fun printName(name: String) {
	println(name)
}

fun main() {
	val name: String? = &quot;Harry&quot;
	name?.let(::printName)
}</code></pre></pre>
<h2 id="apply"><a class="header" href="#apply"><strong>apply</strong></a></h2>
<p>I use <code>apply</code> a lot, especially with old Java libraries.</p>
<p>Instead of:</p>
<pre><code class="language-kotlin noplayground">val person = Person(&quot;Adam&quot;)
person.age = 32
person.city = &quot;London&quot;   
person.address = &quot;bla&quot;  </code></pre>
<p>do:</p>
<pre><code class="language-kotlin noplayground">val person = Person(&quot;Adam&quot;).apply {
	age = 32
	city = &quot;London&quot;   
	address = &quot;bla&quot;       
}</code></pre>
<h2 id="run"><a class="header" href="#run"><strong>run</strong></a></h2>
<ul>
<li>When you need to <em>initialise and compute</em> <em>to derive at one goal</em></li>
<li>When you don't need an object but only use it to compute something</li>
</ul>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>class Person {
	var age = 0
	fun futureAge(years: Int) = age + years
}
val person = Person()
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>person.age = 50
person.doThis()
person.thenThat()
val ageInTenDecades = futureAge(100)
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>val ageInTenDecades = person.run {
	age = 50
	doThis()
	thenThat()
	getFinalFutureAge(100)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="with"><a class="header" href="#with"><strong>with</strong></a></h2>
<ul>
<li>When you already have an object but you need to keep <em>calling</em> its members (maybe useful in tests when you need to assert several things).</li>
</ul>
<p>Similar to <code>run</code></p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>data class Persona(val name: String, val age: Int, val address: String, val occupation: String)

val person = Persona(&quot;Alice&quot;, 100, &quot;Sesame Street&quot;, &quot;Coder&quot;)
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>require(person.name == &quot;Alice&quot;)
require(person.age == 100)
require(person.address == &quot;Sesame Street&quot;)
require(person.occupation == &quot;Coder&quot;)
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>with(person) {
	require(name == &quot;Alice&quot;)
	require(age == 100)
	require(address == &quot;Sesame Street&quot;)
	require(occupation == &quot;Coder&quot;)
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>with(person) {
	applyForBusinessName()
	registerAddress()
	applyForLicence()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="also-duplicate"><a class="header" href="#also-duplicate"><strong><del>also (duplicate?)</del></strong></a></h2>
<p>When you want to create an object and add some side effects to it. Similar to <code>apply</code>.</p>
<p>before</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>val alice = Person(&quot;Alice&quot;, 20)
println(alice)
alice.moveTo(&quot;London&quot;)
<span class="boring">}</span></code></pre></pre>
<p>after</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>val alice = Person(&quot;Alice&quot;, 20)
println(alice)
alice.moveTo(&quot;London&quot;)
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use"><a class="header" href="#use">use</a></h1>
<p>The <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/use.html"><code>use</code></a> block cleans up closeable resources whether an exception is thrown or not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-std-library"><a class="header" href="#java-std-library">Java std library</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-and-objects"><a class="header" href="#classes-and-objects">Classes and objects</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-structure"><a class="header" href="#class-structure">Class structure</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property"><a class="header" href="#property">Property</a></h1>
<p>Class properties are computed once in the lifetime of a class.</p>
<pre><pre class="playground"><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area: Int = this.height * this.width
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}</code></pre></pre>
<p>(JVM only, I think) The getter and setter methods will be generated accordingly for the <code>val</code> and <code>var</code> properties. Attempting to redefine any of these methods throws a compilation error:</p>
<pre><pre class="playground"><code class="language-kotlin">class Rectangle(val height: Int, val width: Int) {
	fun getHeight(): Int {
		return 9
	}
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.getHeight())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-with-getter"><a class="header" href="#property-with-getter">Property with getter</a></h1>
<p>If we want <code>area</code> to be computed on the fly,</p>
<pre><pre class="playground"><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area: Int
		get() {
			return this.width * this.height
		}
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}</code></pre></pre>
<blockquote>
<p>💡 Another pattern to compute <code>area</code> on the fly is to have a <code>getArea</code> method:</p>
<pre><pre class="playground"><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	fun getArea() = this.height * this.width
}

fun main() {
   val rectangle = Rectangle(10, 2)
   println(rectangle.getArea())
   rectangle.height = 100
   println(rectangle.getArea())
}</code></pre></pre>
<p>For me... I prefer the getter properties pattern.</p>
</blockquote>
<p>We can also use the single-line function expression:</p>
<pre><pre class="playground"><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area: Int
		get() = this.width * this.height
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}</code></pre></pre>
<p>Whether we use the single-line function expression or the function block syntax, we can omit the type if it can be inferred:</p>
<pre><pre class="playground"><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area
		get() = this.width * this.height
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}</code></pre></pre>
<p>We can also reduce this getter property to one line:</p>
<pre><pre class="playground"><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	val area get() = this.width * this.height
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}</code></pre></pre>
<p>A getter is always read, not written to. So, this property cannot be a <code>var</code> (otherwise it would be an oxymoron) - it won't compile:</p>
<pre><pre class="playground"><code class="language-kotlin">class Rectangle(var height: Int, var width: Int) {
	var area: Int
		get() = this.width * this.height
}

fun main() {
	val rectangle = Rectangle(10, 2)
	println(rectangle.area)
	rectangle.height = 100
	println(rectangle.area)
}</code></pre></pre>
<p>We can set the read-only property to be private too:</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>class Rectangle(var height: Int, var width: Int) {
	private val area: Int
		get() = this.width * this.height
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>private</code> in <code>private get()</code> is redundant:</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>class Rectangle(var height: Int, var width: Int) {
	private val area: Int
		private get() = this.width * this.height
}
<span class="boring">}</span></code></pre></pre>
<p>The visibility of <code>area</code> must match its <code>get</code> method. Otherwise, it won't compile:</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>class Rectangle(var height: Int, var width: Int) {
	val area: Int
		private get() = this.width * this.height
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-with-setter"><a class="header" href="#property-with-setter">Property with setter</a></h1>
<p>This is how you add a setter:</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
    var age: Int = 30
        set(value) {
            field = value - 1  // alter the age every time we set it
        }
}

fun main() {
	val person = Person()
	person.age = 20
	println(person.age)
}</code></pre></pre>
<blockquote>
<p>💡 <code>set(value)</code> is actually <code>set(value: Int)</code>. The type of <code>value</code> is the same as the type of the property, hence you don't need to type it. The name <code>value</code> is a convention, but you can rename it just like you would any other function.</p>
</blockquote>
<blockquote>
<p>💡 <code>field</code> (&quot;backing field&quot;) is like the &quot;internal value&quot; of the property, if you may.</p>
</blockquote>
<p>You cannot make <code>age</code> read-only because you are writing value to it (&quot;setter&quot;). So this will fail:</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
    val age: Int = 30
        set(value) {
            field = value - 1  // alter the age every time we set it
        }
}

fun main() {
	val person = Person()
	person.age = 20
	println(person.age)
}</code></pre></pre>
<p>You also need to provide an initial value because it assigns the backing field <code>field</code> directly. This won't compile because none is set:</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
    var age: Int
        set(value) {
            field = value - 1  // alter the age every time we set it
        }
}

fun main() {
	val person = Person()
	person.age = 20
	println(person.age)
}</code></pre></pre>
<p>⚠️ Be careful of recursion which will lead to stack overflow - the compiler doesn't warn. The following example set <code>age</code> to 20, which calls <code>alterAge</code>, which in turn sets <code>this.age</code>, which calls <code>alterAge</code>,  which in turn sets <code>this.age</code>, ...</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
    var age: Int = 30
        set(value) {
            alterAge(value)
        }

    private fun alterAge(newAge: Int) {
        this.age = newAge - 1
    }
}

fun main() {
	val person = Person()
	person.age = 20
	println(person.age)
}</code></pre></pre>
<p>Like a getter, you can set the setter to be private:</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
    private var age: Int = 30
        set(value) {
            field = value - 1  // alter the age every time we set it
        }
    fun setAge(age:)
}

fun main() {
	val person = Person()
	println(person.age)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-getter-and-setter"><a class="header" href="#with-getter-and-setter">With getter and setter</a></h1>
<p>For a property that has a getter and a setter, the property:</p>
<ol>
<li>must be <code>var</code></li>
<li>must be initialised</li>
</ol>
<p>The rules of <code>get()</code> and <code>set()</code> come from the previous two sections.</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
	var age: Int = 0 
		get() {
			return field + 1
		}
		set(value) {
			field = value + 100
		}
}

fun main() {
	val person = Person()
	person.age = 100
	println(person.age)
}</code></pre></pre>
<p>Having the getter-and-setter idiom written this way seems to set the focus on the data, which in this case is <code>age</code>. It is also an improvement from the Java way of having a lot of repetitions when defining getters and setters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-property"><a class="header" href="#lazy-property">Lazy property</a></h1>
<p>You can initialise a property lazily, i.e. the value will be computed only when you call it.</p>
<pre><pre class="playground"><code class="language-kotlin">class Person(val height: Float, val weight: Float) {
    val bmi: Float by lazy {
        println(&quot;Computing BMI...&quot;)
        this.weight / (this.height*this.height)
    }
}

fun main() {
    val person = Person(1.70f, 60f)
    println(person.bmi)
}</code></pre></pre>
<p>A lazy property is, by definition, a read-only property. It wouldn't work if you declare it as <code>var</code>:</p>
<pre><pre class="playground"><code class="language-kotlin">class Person(val height: Float, val weight: Float) {
    var bmi: Float by lazy {
        println(&quot;Computing BMI...&quot;)
        this.weight / (this.height*this.height)
    }
}

fun main() {
    val person = Person(1.70f, 60f)
    println(person.bmi)
}</code></pre></pre>
<p>Be careful, though! The lazy property is computed <em>once</em> in the object's lifetime.</p>
<p>(The compiler shouldn't even have allowed this... It should have checked for you whether the <code>this.weight</code> and <code>this.height</code> are mutable.)</p>
<pre><pre class="playground"><code class="language-kotlin">class Person(var height: Float, var weight: Float) {
    val bmi: Float by lazy {
        println(&quot;Computing BMI...&quot;)
        this.weight / (this.height*this.height)
    }
}

fun main() {
    val person = Person(1.70f, 60f)
    println(person.bmi)
    person.weight += 20
    println(person.bmi)
}</code></pre></pre>
<p>The example above should have been a getter property instead since we expect <code>bmi</code> to change.</p>
<blockquote>
<p>💡 Lazy properties are thread-safe: one thread computes, but all threads will see the same value.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="late-init-property"><a class="header" href="#late-init-property">Late-init property</a></h1>
<p>You can initialise (non-null) properties after an object has been created.</p>
<p>A late-init property... the only time I see it used is in Spring Boot.</p>
<p>Because it will be initialised after the creation of an object, the property must be <code>var</code>.</p>
<p><a href="https://stackoverflow.com/questions/36623177/kotlin-property-initialization-using-by-lazy-vs-lateinit">https://stackoverflow.com/questions/36623177/kotlin-property-initialization-using-by-lazy-vs-lateinit</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="companion-object"><a class="header" href="#companion-object">Companion object</a></h1>
<p>An object declaration inside a class is called a <code>companion object</code>. These are singleton objects that are tied to a class, not the instance.</p>
<p>Companion objects are usually used for:</p>
<ol>
<li>Declaring constants (see <strong>Compile-time constants</strong>)</li>
<li>Declaring factory methods</li>
</ol>
<p>Here is an example of using a <code>companion object</code> to declare both a constant and a factory method:</p>
<pre><pre class="playground"><code class="language-kotlin">class Person(val age: Int) {
    companion object {
        const val AGE_AT_ENROLMENT = 18

        fun createStudent(): Person {
            return Person(age = AGE_AT_ENROLMENT)
        }
    }
}

fun main() {
    val person = Person.createStudent()
    println(person.age)
}</code></pre></pre>
<p>You can access the properties in a companion object from a class:</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
    companion object {
        val hobbies = listOf(&quot;swimming&quot;, &quot;jogging&quot;)
    }
}

fun main() {
    println(Person.hobbies)
}</code></pre></pre>
<p>You can even access the <code>object</code> itself:</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
    companion object {
        val hobbies = listOf(&quot;swimming&quot;, &quot;jogging&quot;)
    }
}

fun main() {
    println(Person.Companion)
    println(Person.Companion.hobbies)
}</code></pre></pre>
<p>You cannot, however, access these objects from an instance (you need reflection for that):</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
    companion object {
        val hobbies = listOf(&quot;swimming&quot;, &quot;jogging&quot;)
    }
}

fun main() {
    val person = Person()
    println(person.hobbies)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<ul>
<li><a href="classes_and_objects/class_structure/methods.html#equals"><code>equals</code></a></li>
<li><a href="classes_and_objects/class_structure/methods.html#hashcode"><code>hashCode</code></a></li>
<li><a href="classes_and_objects/class_structure/methods.html#tostring"><code>toString</code></a></li>
<li>Operator overloading - includes <code>invoke</code> and <code>compareTo</code>. See <a href="https://kotlinlang.org/docs/operator-overloading.html">docs</a>.</li>
</ul>
<hr />
<h2 id="equals"><a class="header" href="#equals"><code>equals</code></a></h2>
<p>Suppose you have</p>
<pre><pre class="playground"><code class="language-kotlin">class StringWrapper(private val str: String)

fun main() {
    val wrapper1 = StringWrapper(&quot;jonas&quot;)
    val wrapper2 = StringWrapper(&quot;jonas&quot;)
    println(wrapper1 == wrapper2)  // you want this to be true
}</code></pre></pre>
<p>To make <code>wrapper1 == wrapper2</code> return <code>true</code>, we can override the <code>equals</code> operator:</p>
<pre><pre class="playground"><code class="language-kotlin">class StringWrapper(private val str: String) {
    override fun equals(other: Any?): Boolean {
        return when (other) {
            is StringWrapper -&gt; str == other.str
            is String -&gt; str == other
            else -&gt; false
        }
    }
}

fun main() {
    val wrapper1 = StringWrapper(&quot;jonas&quot;)
    val wrapper2 = StringWrapper(&quot;jonas&quot;)

    println(wrapper1 == wrapper2)
    println(wrapper1.equals(wrapper2))
    // println(wrapper1 == &quot;jonas&quot;)  // this won't work
    println(wrapper1.equals(&quot;jonas&quot;))
}</code></pre></pre>
<p>⚠️ But that's not enough. You need to make sure that you fulfil the <code>hashCode</code> <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/hash-code.html">contract</a>.</p>
<h2 id="hashcode"><a class="header" href="#hashcode"><code>hashCode</code></a></h2>
<p>Afaik, you would normally implement <code>hashCode</code> and <code>equals</code> together.</p>
<p>This is the implementation of <code>StringWrapper</code> that overrides both <code>hashCode</code> and <code>equals</code> functions.</p>
<pre><pre class="playground"><code class="language-kotlin">class StringWrapper(private val str: String) {

    override fun hashCode(): Int {
        return str.hashCode()
    }

    override fun equals(other: Any?): Boolean {
        return when (other) {
            is StringWrapper -&gt; str.hashCode() == other.hashCode()
            is String -&gt; str.hashCode() == other.hashCode()
            else -&gt; false
        }
    }
}

fun main() {
    val wrapper1 = StringWrapper(&quot;jonas&quot;)
    val wrapper2 = StringWrapper(&quot;jonas&quot;)

    println(wrapper1 == wrapper2)
    println(wrapper1.hashCode() == wrapper2.hashCode())
    println(&quot;jonas&quot;.hashCode() == wrapper1.hashCode())
    println(&quot;jonas&quot;.hashCode() == wrapper2.hashCode())
}</code></pre></pre>
<h2 id="tostring"><a class="header" href="#tostring"><code>toString</code></a></h2>
<p>The default string representation is the class name, followed by <code>@</code>, and the object's hash code (in hexadecimal):</p>
<pre><pre class="playground"><code class="language-kotlin">class SecureString(str: String)

fun main() {
    val password = SecureString(&quot;pA55w0rd&quot;)
    println(&quot;Password is: $password&quot;)
    println(&quot;%x&quot;.format(password.hashCode()))
}</code></pre></pre>
<p>We can override <code>toString</code>:</p>
<pre><pre class="playground"><code class="language-kotlin">class SecureString(str: String) {
    override fun toString(): String {
        return &quot;***** (redacted)&quot;
    }
}

fun main() {
    val password = SecureString(&quot;pA55w0rd&quot;)
    println(&quot;Password is: $password&quot;)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructor"><a class="header" href="#constructor">Constructor</a></h1>
<p>Perhaps the only idiomatic way is to have one primary constructor without the <code>constructor</code> keyword (first example). </p>
<p>If there are multiple constructors, use either (i) a primary constructor with default parameters or (ii) the factory pattern.</p>
<h3 id="one-primary-constructor"><a class="header" href="#one-primary-constructor">One primary constructor</a></h3>
<pre><pre class="playground"><code class="language-kotlin">class Person(name: String, age: Int)

fun main() {
	val person = Person(&quot;Jonah&quot;, 10)
	println(person)
}</code></pre></pre>
<h3 id="one-primary-constructor-with-computed-property"><a class="header" href="#one-primary-constructor-with-computed-property">One primary constructor with computed property???</a></h3>
<pre><pre class="playground"><code class="language-kotlin">class Rectangle(
	height: Int, 
	width: Int, 
	val area: Int = height * width,
)

fun main() {
	val rectangle = Rectangle(2, 10)
	println(rectangle.area)
}</code></pre></pre>
<h3 id="one-primary-constructor-with-constructor-keyword"><a class="header" href="#one-primary-constructor-with-constructor-keyword">One primary constructor (with <code>constructor</code> keyword)</a></h3>
<pre><pre class="playground"><code class="language-kotlin">class Person constructor(name: String, age: Int)

fun main() {
	val person = Person(&quot;Jonah&quot;, 10)
	println(person)
}</code></pre></pre>
<h3 id="one-primary-and-one-secondary-constructor"><a class="header" href="#one-primary-and-one-secondary-constructor">One primary and one secondary constructor</a></h3>
<pre><pre class="playground"><code class="language-kotlin">class Person(name: String, age: Int) {
	constructor(name: String): this(name, 20)
}

fun main() {
	val person = Person(&quot;Jonah&quot;)
	println(person)
}</code></pre></pre>
<h3 id="one-primary-and-one-secondary-constructor-with-block"><a class="header" href="#one-primary-and-one-secondary-constructor-with-block">One primary and one secondary constructor with block</a></h3>
<pre><pre class="playground"><code class="language-kotlin">class Person(name: String, age: Int) {
	constructor(name: String): this(name, 20) {
		println(&quot;Constructing...&quot;)
	}
}

fun main() {
	val person = Person(&quot;Jonah&quot;)
	println(person)
}</code></pre></pre>
<h3 id="one-secondary-constructor-only"><a class="header" href="#one-secondary-constructor-only">One secondary constructor only</a></h3>
<pre><pre class="playground"><code class="language-kotlin">class Person {
	constructor(name: String) {
		println(&quot;Constructing $name&quot;)
	}
}

fun main() {
	val person = Person(&quot;Jonah&quot;)
	println(person)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initializer-block"><a class="header" href="#initializer-block">Initializer block</a></h1>
<p>Are init blocks idiomatic, though?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interface"><a class="header" href="#interface">Interface</a></h1>
<p>Note that in Kotlin, interfaces can declare functions <em>and/or properties</em>. Here is an example with a property:</p>
<pre><pre class="playground"><code class="language-kotlin">interface Hello {
    val name: String
}

class Greeter : Hello {
    override val name: String
        get() = &quot;Jonas&quot;
}

fun main() {
    val greeter = Greeter()
    println(greeter.name)
}</code></pre></pre>
<p>Interfaces cannot have private abstract properties or functions unless they are concrete implementations.</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>interface Hello {
    private fun greet()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-class"><a class="header" href="#data-class">Data class</a></h1>
<p>Data class is like a <code>class</code> but implements for you:</p>
<ul>
<li><code>equals()</code> and <code>hashCode()</code></li>
<li><code>toString()</code></li>
<li><code>copy()</code></li>
</ul>
<p>Data class is the idiomatic way to define objects that contains only data. A common operation you would perform on data is comparison - this is where the <code>equals</code> function comes in handy.</p>
<p>Note that data classes, however, do not translate to Java's Records. You need the <code>@JvmRecord</code> annotation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-declaration"><a class="header" href="#object-declaration">Object declaration</a></h1>
<p>Used for singleton or one-time class overrides.</p>
<p>Simple object declaration</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>val someObject = object {
    val num = 5
}
println(someObject.num)
<span class="boring">}</span></code></pre></pre>
<p>Object declaration with a method</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>val someObject = object {
    fun greet() {
        println(&quot;Hello!&quot;)
    }
}
someObject.greet()
<span class="boring">}</span></code></pre></pre>
<p>Object that inherits from an interface</p>
<pre><pre class="playground"><code class="language-kotlin">interface Minimisable {
    fun minimise(): Int
}

fun main() {
    val item = object : Minimisable {
        override fun minimise(): Int {
            return 1
        }
    }
    println(item.minimise())
}</code></pre></pre>
<p>Object declarations work with multiple interfaces too.</p>
<pre><pre class="playground"><code class="language-kotlin">interface Minimisable {
    fun minimise(): Int
}

interface Maximisable {
    fun maximise(): Int
}

fun main() {
    val item = object : Minimisable, Maximisable {
        override fun minimise(): Int {
            return 1
        }
        override fun maximise(): Int {
            return 100
        }
    }
    println(item.minimise())
    println(item.maximise())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-object"><a class="header" href="#data-object">Data object</a></h1>
<p>(Experimental)</p>
<p>Data objects would play nicely with sealed classes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-class"><a class="header" href="#enum-class">Enum class</a></h1>
<p>Useful Kotlin built-in extensions:</p>
<ul>
<li><a href="classes_and_objects/enum_class.html#enumvalueof"><code>enumValueOf</code></a></li>
<li><a href="classes_and_objects/enum_class.html#enumvaluew"><code>enumValues</code></a></li>
</ul>
<hr />
<h2 id="enumvalueof"><a class="header" href="#enumvalueof"><code>enumValueOf</code></a></h2>
<pre><pre class="playground"><code class="language-kotlin">enum class Status {
    Approved,
    Rejected,
}

fun main() {
    val status = enumValueOf&lt;Status&gt;(&quot;Approved&quot;)
    println(status)
}</code></pre></pre>
<p>⚠️ Gotcha: You have to remember to catch the exception yourself if the parse fails (yucks) (instead of the API returning a nullable). Below will throw an <code>IllegalArgumentException</code>:</p>
<pre><pre class="playground"><code class="language-kotlin">enum class Status {
    Approved,
    Rejected,
}

fun main() {
    val status = enumValueOf&lt;Status&gt;(&quot;Approvedssss&quot;)
    println(status)
}</code></pre></pre>
<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/enum-value-of.html">Reference</a></p>
<h2 id="enumvalueof-1"><a class="header" href="#enumvalueof-1"><code>enumValueOf</code></a></h2>
<pre><pre class="playground"><code class="language-kotlin">enum class Status {
    Approved,
    Rejected,
}

fun main() {
    val statuses = enumValues&lt;Status&gt;().toList()
    println(statuses)
}</code></pre></pre>
<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/enum-values.html">Reference</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sealed-class"><a class="header" href="#sealed-class">Sealed class</a></h1>
<p>Sealed classes are a powerful feature in Kotlin. They are akin to the types in Rust and Haskell ecosystem.</p>
<p>A sealed class is idiomatically used as an enum with arbitrary data structures.</p>
<pre><pre class="playground"><code class="language-kotlin">sealed class Employee {
	data class Manager(val name: String, val age: Int): Employee()
	data class SeniorDev(val name: String): Employee()
}

fun main() {
	val employee: Employee = Employee.SeniorDev(&quot;Jonah&quot;)
	when (employee) {
		is Employee.Manager -&gt; println(&quot;Manager: ${employee.name}, Age: ${employee.age}&quot;)
		is Employee.SeniorDev -&gt; println(&quot;SeniorDev: ${employee.name}&quot;)
	}
}</code></pre></pre>
<p>Here is the Rust equivalent of the Kotlin code above.</p>
<pre><code class="language-Rust">enum Employee {
    Manager { name: String, age: u8 },
    SeniorDev { name: String },
}

fn main() {
    let employee = Employee::SeniorDev { name: &quot;Jonah&quot;.to_string() };
    match employee {
        Employee::Manager { name, age } =&gt; println!(&quot;Manager: {}, Age: {}&quot;, name, age),
        Employee::SeniorDev { name } =&gt; println!(&quot;SeniorDev: {}&quot;, name),
    }
}
</code></pre>
<p>Sealed classes is an exciting feature because it gives programmers more flexibility in modelling data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-class"><a class="header" href="#inline-class">Inline class</a></h1>
<p>Inline classes are used to wrap a type.</p>
<p>You would usually do this in place of typealias, or (data) class for performance reasons.</p>
<p>Here is one where we wrap the <code>String</code> type:</p>
<pre><pre class="playground"><code class="language-kotlin">@JvmInline
value class SecureString(val str: String)

fun main() {
    val password = SecureString(&quot;pa55w0rd&quot;)
    println(password)
}</code></pre></pre>
<p>Inline classes only work for a single property (initialised in the primary constructor). The following won't compile because it has two properties:</p>
<pre><pre class="playground"><code class="language-kotlin">@JvmInline
value class SecureString(val str: String, val numChars: Int)

fun main() {
    val password = SecureString(&quot;pa55w0rd&quot;, 1)
    println(password)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-time-constants"><a class="header" href="#compile-time-constants">Compile-time constants</a></h1>
<p>Compile-time constants must be <code>String</code> or primitive type.</p>
<ul>
<li>as a top-level property</li>
<li>in an object declaration</li>
<li>in a companion object</li>
</ul>
<p>At compile-time, the compiler will inline all usages of the constant with its actual value.</p>
<p>As a top-level property</p>
<pre><pre class="playground"><code class="language-kotlin">const val NAME = &quot;Remy&quot;

fun main() {
    println(NAME)
}</code></pre></pre>
<p>In an object declaration</p>
<pre><pre class="playground"><code class="language-kotlin">object Person {
    const val NAME = &quot;Remy&quot;
}

fun main() {
    println(Person.NAME)
}</code></pre></pre>
<p>In a companion object</p>
<pre><pre class="playground"><code class="language-kotlin">class Person {
    companion object {
        const val NAME = &quot;Remy&quot;
    }
}

fun main() {
    println(Person.NAME)
}</code></pre></pre>
<p>These values <em>must be known</em> at compile-time. The following will fail:</p>
<pre><pre class="playground"><code class="language-kotlin">fun someName() = &quot;Remy&quot;

const val NAME = someName()

fun main() {
    println(NAME)
}</code></pre></pre>
<p>Some functions work, however, due to <em>const evaluation</em>:</p>
<pre><pre class="playground"><code class="language-kotlin">const val CHARACTER = &quot;Hello&quot;.get(0)

fun main() {
    println(CHARACTER)
}</code></pre></pre>
<p>If we look at the <code>get</code> method we see the annotation <code>@kotlin.internal.IntrinsicConstEvaluation</code>:</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>@kotlin.internal.IntrinsicConstEvaluation
public override fun get(index: Int): Char
<span class="boring">}</span></code></pre></pre>
<p>Documentation for <code>IntrinsicConstEvaluation</code>:</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>/**
 * When applied to a function or property, enables a compiler optimization that evaluates that function or property
 * at compile-time and replaces calls to it with the computed result.
 */
@Target(AnnotationTarget.CONSTRUCTOR, AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY)
@Retention(AnnotationRetention.BINARY)
@SinceKotlin(&quot;1.7&quot;)
internal annotation class IntrinsicConstEvaluation
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-handling"><a class="header" href="#exception-handling">Exception handling</a></h1>
<div class="table-wrapper"><table><thead><tr><th>API</th><th>Client code handling</th><th>Enforced?</th></tr></thead><tbody>
<tr><td><code>throw</code> expression</td><td><code>try</code>/<code>except</code></td><td>No</td></tr>
<tr><td>Nullable return type</td><td>Type system</td><td>Yes, by the type system</td></tr>
<tr><td>Sealed class return type</td><td>Type system</td><td>Yes, by the type system</td></tr>
</tbody></table>
</div>
<p>The sealed class idiom can be seen in the standard library's <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/"><code>Result</code></a> or Arrow's <a href="https://arrow-kt.io/docs/apidocs/arrow-core/arrow.core/-either/"><code>Either</code></a>.</p>
<blockquote>
<p>⚠️ Take note that the compiler doesn't enforce catching exceptions thrown by libraries.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<p>Property</p>
<pre><pre class="playground"><code class="language-kotlin">val String.someChar: Char
	get() {
		return 'X'
	}

fun main() {
	println(&quot;hello&quot;.someChar)
}</code></pre></pre>
<p>Companion object</p>
<pre><pre class="playground"><code class="language-kotlin">class SomeClass {
	companion object {}
}

fun SomeClass.Companion.someFunction(): String {
	return &quot;dd&quot;
}

fun main() {
	println(SomeClass.someFunction())
}</code></pre></pre>
<p>This won't work if there isn't an existing companion object</p>
<pre><pre class="playground"><code class="language-kotlin">class SomeClass

fun SomeClass.Companion.someFunction(): String {
	return &quot;dd&quot;
}

fun main() {
	println(SomeClass.Companion.someFunction())
}</code></pre></pre>
<p>Anything</p>
<pre><pre class="playground"><code class="language-kotlin">fun Any?.someMethod() = &quot;hello&quot;

fun main() {
	val num = 5
	println(num.someMethod())
}</code></pre></pre>
<blockquote>
<p>I personally won't do this, because how are you going to test this for all the different types?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Example 1</p>
<pre><pre class="playground"><code class="language-kotlin">data class Box&lt;T&gt;(val item: T)

fun main() {
    val box = Box(10)
    println(box)
}</code></pre></pre>
<p>Example 2</p>
<pre><pre class="playground"><code class="language-kotlin">fun &lt;T&gt; printItem(type: T): String {
    return when (type) {
        is Int -&gt; &quot;Int&quot;
        is String -&gt; &quot;String&quot;
        else -&gt; &quot;everything else&quot;
    }
}

fun main() {
    println(printItem(10))
    println(printItem(&quot;Hello&quot;))
}</code></pre></pre>
<p>Example 3</p>
<pre><pre class="playground"><code class="language-kotlin">data class Box&lt;S, T&gt;(
    val item1: S,
    val item2: T,
)

fun main() {
    val box = Box(10, &quot;100&quot;)
    println(box)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upper-bounds"><a class="header" href="#upper-bounds">Upper bounds</a></h1>
<p>Default upper bound is <code>Any?</code>.</p>
<p>Single upperbound</p>
<pre><pre class="playground"><code class="language-kotlin">interface Minimisable {
    fun minimise(): Int
}

class Box&lt;T: Minimisable&gt;(val item: T) {
    fun getMinimisedItem(): Int {
        return item.minimise()
    }
}

fun main() {
    val item = object : Minimisable {
        override fun minimise(): Int {
            return 100
        }
    }
    val box = Box(item)
    println(box)
}</code></pre></pre>
<pre><pre class="playground"><code class="language-kotlin">class Box&lt;T&gt;(val item: T) where T: Minimisable {
fun getMinimisedItem(): Int {
    return item.minimise()
    }
}

fun main() {
    val item = object : Minimisable {
        override fun minimise(): Int {
            return 100
        }
    }
    val box = Box(item)
}</code></pre></pre>
<p>Multiple upperbounds</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>interface Maximisable {
    fun maximise(): Int
}

class Box&lt;T&gt;(private val item: T)
    where T: Minimisable, T: Maximisable
{
    fun getMinimisedItem(): Int {
        return item.minimise()
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-kotlin">class Stuff: Minimisable, Maximisable {
    override fun minimise(): Int {
        return 5
    }
    override fun maximise(): Int {
        return 100
    }
}
fun main() {
    val item = Stuff()
    val box = Box(item)
}</code></pre></pre>
<p>multiple types</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>class Box&lt;S, T&gt;(private val item1: S,private val item2: T,) {
fun getItem1(): S {
return item1
    }
fun getItem2(): T {
return item2
    }
}
val box = Box(10, &quot;item2&quot;)
<span class="boring">}</span></code></pre></pre>
<p>multiple types &amp; multiple bounds</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>class Box&lt;S, T&gt;(
private val item1: S,
private val item2: T,
)
where S:Minimisable, S:Maximisable, T:Maximisable
{
fun getItem1(): S {
return item1
    }
fun getItem2(): T {
return item2
    }
}
val item = Stuff()
val it =object:Maximisable{
override fun maximise(): Int {
return 10
    }
}
val box = Box(item, it)
<span class="boring">}</span></code></pre></pre>
<p>Inheriting</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>class Box300(item:Minimisable): Box3&lt;Minimisable&gt;(item)
class Stufff:Minimisable{
override funminimise(): Int {
TODO(&quot;Not yet implemented&quot;)
    }
}
class Box301(item: Stufff): Box3&lt;Stufff&gt;(item)
class Box302&lt;T:Minimisable&gt;(item: T): Box3&lt;T&gt;(item)
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-erasure"><a class="header" href="#type-erasure">Type erasure</a></h1>
<p>Type erasure is perhaps a misnomer.</p>
<p>All possible forms of a generic type will be reduced to a simple raw type after compilation. This reduction is known as <em>type erasure</em>. What this means is that <code>List&lt;String&gt;</code> and <code>List&lt;Int&gt;</code> will be <code>List</code> at runtime.</p>
<p>So this would work:</p>
<pre><pre class="playground"><code class="language-kotlin">class Box(private val name: String) {
    companion object {
        fun &lt;T&gt; from(value: T): Box {
            return when (value) {
                is Double -&gt; Box(&quot;Double&quot;)
                else -&gt; Box(&quot;Not double&quot;)
            }
        }
    }
    override fun toString(): String {
        return &quot;Box(\&quot;$name\&quot;)&quot;
    }
}

fun main() {
    println(Box.from(5))
    println(Box.from(&quot;Hello&quot;))
}</code></pre></pre>
<p>But it will not compile here, because of the type erasure behaviour:</p>
<pre><pre class="playground"><code class="language-kotlin">class Item&lt;T&gt;(value: T)

class Box(private val name: String) {
    companion object {
        fun &lt;T&gt; from(value: T): Box {
            return when (value) {
                is Item&lt;T&gt; -&gt; Box(&quot;Generics&quot;)  // this line is problematic!
                else -&gt; Box(&quot;Not generics&quot;)
            }
        }
    }
    override fun toString(): String {
        return &quot;Box(\&quot;$name\&quot;)&quot;
    }
}

fun main() {
    println(Box.from(Item(1000)))
    println(Box.from(&quot;Hello&quot;))
}</code></pre></pre>
<p>Change <code>Item&lt;T&gt;</code> to <code>Item&lt;*&gt;</code> and it works!</p>
<pre><pre class="playground"><code class="language-kotlin">class Item&lt;T&gt;(value: T)

class Box(private val name: String) {
    companion object {
        fun &lt;T&gt; from(value: T): Box {
            return when (value) {
                is Item&lt;*&gt; -&gt; Box(&quot;Generics&quot;)  // change this line
                else -&gt; Box(&quot;Not generics&quot;)
            }
        }
    }
    override fun toString(): String {
        return &quot;Box(\&quot;$name\&quot;)&quot;
    }
}

fun main() {
    println(Box.from(Item(1000)))
    println(Box.from(&quot;Hello&quot;))
}</code></pre></pre>
<p>Notice the decompiled Java for the <code>Item&lt;T&gt;</code> class - it doesn't have any information about the type <code>T</code> at all!</p>
<pre><code class="language-java">public final class Item {
   public Item(Object value) {}
}
</code></pre>
<p>Let's look at the decompiled Java code for creating the objects:</p>
<pre><code class="language-java">public static final void main() {
    Box var0 = Box.Companion.from(new Item(1000));
    System.out.println(var0);
    var0 = Box.Companion.from(&quot;Hello&quot;);
    System.out.println(var0);
}
</code></pre>
<p>The <code>from</code> function only checks for the &quot;outermost&quot; instance, which is either <code>Item</code> or not:</p>
<pre><code class="language-java">public final class Box {

    private final String name;

    public static final class Companion {
        public final Box from(Object value) {
            return value instanceof Item ? new Box(&quot;Generics&quot;) : new Box(&quot;Not string&quot;);
        }
    }

    // omitted for brevity
}
</code></pre>
<p>Need to use <code>reified</code>. Used together with <code>inline</code>.</p>
<pre><pre class="playground"><code class="language-kotlin">class Item&lt;T&gt;(value: T) {
    inline fun accessValue(): T
}

class Box(private val name: String) {
    companion object {
        fun &lt;T&gt; from(value: T): Box {
            return when (value) {
                is Item&lt;*&gt; -&gt; Box(&quot;Generics&quot;)  // change this line
                else -&gt; Box(&quot;Not generics&quot;)
            }
        }
    }
    override fun toString(): String {
        return &quot;Box(\&quot;$name\&quot;)&quot;
    }
}

fun main() {
    println(Box.from(Item(1000)))
    println(Box.from(&quot;Hello&quot;))
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflection"><a class="header" href="#reflection">Reflection</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<h2 id="class-reference"><a class="header" href="#class-reference">Class reference</a></h2>
<p>A class reference has the type <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/"><code>KClass</code></a> with properties like:</p>
<ul>
<li><code>java</code> - runtime Java class reference</li>
<li><code>javaClass</code> runtime Java class of an object</li>
<li><code>qualifiedName</code></li>
</ul>
<pre><pre class="playground"><code class="language-kotlin">class Person(name: String, age: Int) {
    fun laugh() { 
        println(&quot;haha&quot;)
    }
}

fun main() {
    val klass = Person::class
    println(klass.java)
    // println(klass.javaClass)
    println(klass.qualifiedName)
    println(klass.simpleName)
    println(klass.members)
    // println(klass.declaredMemberProperties)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java"><a class="header" href="#java">Java</a></h1>
<ul>
<li><code>.getMethod(&quot;somePropertyName&quot;)</code></li>
<li><code>.invoke(someObj, args...)</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-and-non-local-return"><a class="header" href="#local-and-non-local-return">Local and non-local return</a></h1>
<p>Local return vs. non-local return in lambda function &amp; anonymous function</p>
<p>When you <code>return</code> from a lambda, you do a non-local (non-lambda) return, i.e. return to the function (eg. main()) which called <code>someFunction</code>. </p>
<p>Another way to look at this is this means that the <code>return</code> belongs to <code>someFunction</code>.</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>fun someFunction() {

    val numbers = 1..10

    numbers.forEach {
        if (it % 5 == 0)
            return  // this return 'belongs' to someFunction
        println(&quot;Hello $it&quot;)
    }
}

someFunction()
<span class="boring">}</span></code></pre></pre>
<p>This is the same as <code>return@someFunction</code>.</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>fun someFunction() {
    val numbers = 1..10

    numbers.forEach {
        if (it % 5 == 0)
            return@someFunction
        println(&quot;Hello $it&quot;)
    }
}

someFunction()
<span class="boring">}</span></code></pre></pre>
<p>However, if you <code>return</code> from an anonymous function, you do a local return (return to this anonymous function) (to <code>someFunction2</code>).</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>fun someFunction2() {
    val numbers = 1..10

    numbers.forEach(fun(x) {
        if (x % 5 == 0)
            return  // this does not belong to someFunction2
        println(&quot;Hello $x&quot;)
    })
}

someFunction2()
<span class="boring">}</span></code></pre></pre>
<p>Unless of course you specify that you want to do a non-local return.</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>fun someFunction2() {
    val numbers = 1..10

    numbers.forEach(fun(x) {
        if (x % 5 == 0)
            return@someFunction2  // this 'belongs' to someFunction2
        println(&quot;Hello $x&quot;)
    })
}

someFunction2()
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-interoperability"><a class="header" href="#java-interoperability">Java interoperability</a></h1>
<h2 id="named-arguments"><a class="header" href="#named-arguments">Named arguments</a></h2>
<p>Not supported when calling Java code.</p>
<h2 id="platform-types"><a class="header" href="#platform-types">Platform types</a></h2>
<p><a href="https://kotlinlang.org/docs/java-interop.html#notation-for-platform-types">Notation for platform types</a></p>
<ul>
<li><code>T!</code> = <code>T</code> or <code>T?</code></li>
<li><code>(Mutable)Collection&lt;T&gt;!</code> = <code>Collection&lt;T&gt;</code> or <code>Collection&lt;T&gt;?</code> or <code>MutableCollection&lt;T&gt;</code> or <code>MutableCollection&lt;T&gt;?</code></li>
<li><code>Array&lt;(out) T&gt;!</code> = <code>Array&lt;T&gt;</code> or <code>Array&lt;T&gt;?</code> where <code>T</code> can be a subtype</li>
</ul>
<p>Example</p>
<pre><code class="language-kotlin noplayground">import org.springframework.http.HttpHeaders

val requestHeader = HttpHeaders()
val headerValue = requestHeader[&quot;header-key&quot;]</code></pre>
<p>where the notation of <code>headerValue</code> is given by <code>(Mutable)List&lt;String!&gt;?</code>. This means it is one of the following 😲:</p>
<ul>
<li><code>List&lt;String&gt;?</code></li>
<li><code>List&lt;String?&gt;?</code></li>
<li><code>MutableList&lt;String&gt;?</code></li>
<li><code>MutableList&lt;String?&gt;?</code></li>
</ul>
<h2 id="static"><a class="header" href="#static">Static</a></h2>
<p>Previously</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>object Utils {
    fun doSomething() {
        // logic here
    }
}
<span class="boring">}</span></code></pre></pre>
<p>But if we </p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>object Utils {

    @JvmStatic
    fun doSomething() {
        // logic here
    }
}
<span class="boring">}</span></code></pre></pre>
<p>JvmOverloads</p>
<p>such that in Java</p>
<pre><code class="language-java">Utils.INSTANCE.doSomething();
</code></pre>
<p>then in Java</p>
<pre><code class="language-java">Utils.doSomething();
</code></pre>
<h2 id="inline"><a class="header" href="#inline">Inline</a></h2>
<p><code>@JvmInline</code></p>
<p>An <code>inline</code> function with <code>reified</code> is not callable from Java.</p>
<h2 id="java-records"><a class="header" href="#java-records">Java records</a></h2>
<p>Available in JDK 16</p>
<pre><code class="language-kotlin noplayground">@JvmRecord
data class User(val name: String, val age: Int)

fun main() {
    val user = User(name = &quot;Me&quot;, age = 27)
    println(user)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gotchas"><a class="header" href="#gotchas">Gotchas</a></h1>
<ul>
<li>
<p>Unsafe cast</p>
</li>
<li>
<p>Unhandled exceptions in Kotlin collections</p>
</li>
<li>
<p>Platform types</p>
</li>
<li>
<p>1..10 iteration inclusive</p>
</li>
<li>
<p>Unsafe DSL</p>
</li>
<li>
<p>Bytearray to String</p>
<p>Correct way:</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>var s = String(encryption.encrypt(&quot;fatcow&quot;), StandardCharsets.UTF_8)
<span class="boring">}</span></code></pre></pre>
<p>&quot;The common mistake is trying to use the bytes.toString() to get the string from the bytes; The bytes.toString() only returns the address of the object in memory, NOT converting byte[] to a string!&quot;</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-design-patterns"><a class="header" href="#common-design-patterns">Common design patterns</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="singleton"><a class="header" href="#singleton">Singleton</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory-method"><a class="header" href="#factory-method">Factory method</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builder"><a class="header" href="#builder">Builder</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prototype"><a class="header" href="#prototype">Prototype</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delegate-pattern"><a class="header" href="#delegate-pattern">Delegate pattern</a></h1>
<p>The delegation pattern is an alternative to implementation inheritance.</p>
<p>Personally, this pattern feels... quite awkward to use.</p>
<ol>
<li>Inherits from a common interface</li>
<li><strong>Constructor takes in another object</strong> that inherits from this interface</li>
</ol>
<pre><pre class="playground"><code class="language-kotlin">interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

class Derived(b: Base) : Base by b

fun main() {
    val b = BaseImpl(10)
    Derived(b).print()
}</code></pre></pre>
<aside>
⚠️ Only *interfaces* can be delegated to
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsr"><a class="header" href="#jsr">JSR</a></h1>
<p>Java Specification Requests - Standards for the Java platform</p>
<h2 id="bean-validation"><a class="header" href="#bean-validation">Bean Validation</a></h2>
<p><a href="https://jcp.org/en/jsr/detail?id=303">JSR-303</a> (Bean Validation) and <a href="https://jcp.org/en/jsr/detail?id=380">JSR-380</a> (Bean Validation 2.0)</p>
<p>package <code>javax.validation</code></p>
<ul>
<li>General - <code>@NotEmpty</code>, <code>@NotBlank</code></li>
<li>Numbers - <code>@Min</code></li>
<li>Dates - <code>@Future</code>, <code>@Past</code> etc.</li>
<li>Emails - <code>@Email</code></li>
<li>Collections - <code>@Size</code></li>
</ul>
<h2 id="annotations-for-software-defect-detection"><a class="header" href="#annotations-for-software-defect-detection">Annotations for Software Defect Detection</a></h2>
<p><a href="https://jcp.org/en/jsr/detail?id=305">JSR-305</a></p>
<p>These annotations include nullness like <code>@NonNull</code> and <code>@UnderMigration</code>.</p>
<p>This can also be included in the compiler flag <code>-Xjsr305</code>.</p>
<h2 id="scripting-for-the-java-platform"><a class="header" href="#scripting-for-the-java-platform">Scripting for the Java Platform</a></h2>
<p><a href="https://jcp.org/en/jsr/detail?id=223">JSR-223</a></p>
<p><code>javax.scripting</code></p>
<h2 id="contexts-and-dependency-injection-for-java-20"><a class="header" href="#contexts-and-dependency-injection-for-java-20">Contexts and Dependency Injection for Java 2.0</a></h2>
<p>Aka CDI</p>
<p><a href="https://jcp.org/en/jsr/detail?id=365">JSR-365</a></p>
<p>Includes <code>@Inject</code> specification</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-and-build"><a class="header" href="#compile-and-build">Compile and build</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-options"><a class="header" href="#compiler-options">Compiler options</a></h1>
<pre><code class="language-sh">kotlinc hello.kt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-options-1"><a class="header" href="#compiler-options-1">Compiler options</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-repository"><a class="header" href="#local-repository">Local repository</a></h1>
<p>Local repository is stored in <code>~/.m2/repository</code>. You can publish there too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimisations"><a class="header" href="#optimisations">Optimisations</a></h1>
<h2 id="inline-1"><a class="header" href="#inline-1">Inline</a></h2>
<p><code>inline</code> functions make sense to be used if they are <em>higher-order functions. inline is copy-and-paste.</em> </p>
<p>Inline classes will use the <code>value</code> modifier. Use <code>@JvmInline</code> for java backends.</p>
<p><code>const</code> for compile-time constants. These are read-only properties (so it's will always be <code>const val</code>) that must be initialised with a primitive type or <code>String</code> type. Declaration is done either at top-level, member of an object declaration, or a companion object. </p>
<p><code>reified</code> for generic types, so that the type information is available during runtime. This directive is used together with the <code>inline</code> function. Java's solution for this is very verbose.</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>fun &lt;T: Any&gt; doSomething(value: T, type: KClass&lt;T&gt;) {
    println(&quot;Doing something with type: ${type.simpleName}&quot;)       // OK
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>value class Person {

}
<span class="boring">}</span></code></pre></pre>
<p>but Kotlin handles it better:</p>
<pre><pre class="playground"><code class="language-kotlin"><span class="boring">fun main() {
</span>inline fun &lt;reified T&gt; doSomething(value: T) {
    println(&quot;Doing something with type: ${T::class.simpleName}&quot;)    // OK
}
<span class="boring">}</span></code></pre></pre>
<p>While copying the body of an inline function, the compiler also replaces the type parameter T with the actual type argument that is specified or inferred in the function call.</p>
<h2 id="tail-recursion"><a class="header" href="#tail-recursion">Tail recursion</a></h2>
<h2 id="arrays-with-primitives"><a class="header" href="#arrays-with-primitives">Arrays with primitives</a></h2>
<p>https://kt.academy/article/ek-arrays</p>
<h2 id="sequence"><a class="header" href="#sequence">Sequence</a></h2>
<p>https://kt.academy/article/ek-sequence</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
