<!DOCTYPE html>
<html lang="en">

<head>
    <title>TestFlow</title>

    <!-- Load TensorFlow.js. This is required to use MobileNet. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.11.7"> </script>
    <!-- Load the MobileNet model. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@0.1.1"> </script>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@0.4.2"></script>
    <script class="jsbin" src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
    <script class="jsbin" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.0/jquery-ui.min.js"></script>

</head>

<body>
    <!-- Replace this with your image. Make sure CORS settings allow reading the image! -->

    <img id="img" src="cat.jpg" width="224" height="224" />

    <h2>Upload image for ImageNet classification</h2>
    <input type='file' onchange="readURL(this);" />
    <img id="blah" src="#" alt="your image" width="224" />

    <h2>Classify</h2>
    <button onclick="myFunction()">Click me</button>

    <!-- Place your code in the script tag below. You can also use an external .js file -->
    <script>
        // Notice there is no 'import' statement. 'mobilenet' and 'tf' is
        // available on the index-page because of the script tag above.

        // const jsonUpload = document.getElementById('json-upload');
        // const weightsUpload = document.getElementById('weights-upload');

        // const model = await tf.loadModel(
        //     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));

        const MODEL_URL = 'mobilenet/web_model/savedmodel.pb';
        const WEIGHTS_URL = 'mobilenet/web_model/saved.json';
        const PREPROCESS_DIVISOR = tf.scalar(255 / 2);
        const INPUT_NODE_NAME = 'input';
        const OUTPUT_NODE_NAME = 'final_result';

        function predict(input) {
            const preprocessedInput = tf.div(
                tf.sub(input.asType('float32'), PREPROCESS_DIVISOR),
                PREPROCESS_DIVISOR);
            const reshapedInput =
                preprocessedInput.reshape([1, ...preprocessedInput.shape]);
            return reshapedInput;
            // return model.execute(
            //     { [INPUT_NODE_NAME]: reshapedInput }, OUTPUT_NODE_NAME);
        }

        function readURL(input) {
            if (input.files && input.files[0]) {
                var reader = new FileReader();

                reader.onload = function (e) {
                    $('#blah')
                        .attr('src', e.target.result)
                        .width(150)
                        .height(200);
                };

                reader.readAsDataURL(input.files[0]);
            }
        }

        function myFunction() {
            var img2 = document.getElementById('blah');
            mobilenet.load().then(model => {
                // Classify the image.
                model.classify(img2).then(predictions => {
                    console.log('Predictions: ');
                    console.log(predictions);
                });
            });
        }

        var imageData = document.getElementById('img');

        // Convert the canvas pixels to a Tensor of the matching shape
        let img = tf.fromPixels(imageData, 3);
        img = img.reshape([1, 224, 224, 3]);
        img = tf.cast(img, 'float32');

        // Load the model.
        // tf.loadFrozenModel(MODEL_URL, WEIGHTS_URL).then(model => {
        //     // Classify the image.
        //     model.execute({ input: img }).then(predictions => {
        //         console.log('Predictions: ');
        //         console.log(predictions);
        //     });
        // });

        function loadModel() {
            tf.loadFrozenModel(MODEL_URL, WEIGHTS_URL);
        }

        const model = loadModel();
        console.log(model);
        results = model.execute(img);

        // model.execute({ input: tf.fromPixels(img) })

    </script>
</body>